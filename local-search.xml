<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>聚类与降维</title>
    <link href="/2020/07/05/%E8%81%9A%E7%B1%BB%E4%B8%8E%E9%99%8D%E7%BB%B4/"/>
    <url>/2020/07/05/%E8%81%9A%E7%B1%BB%E4%B8%8E%E9%99%8D%E7%BB%B4/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="聚类任务"><a href="#聚类任务" class="headerlink" title="聚类任务"></a>聚类任务</h1><p>聚类算法是一个典型的无监督学习，训练的数据没有任何标签。聚类算法将数据集中的样本划分为若干个通常是不相交的子集，每个子集成为一个“簇”（cluster）。</p><h2 id="K均值算法（K-Means-Algorithm）"><a href="#K均值算法（K-Means-Algorithm）" class="headerlink" title="K均值算法（K-Means Algorithm）"></a>K均值算法（K-Means Algorithm）</h2><p>K均值算法是最普及的聚类算法，算法接受一个未标记的数据集，然后根据数据聚类成不同的组。</p><p>K均值是一个迭代算法，假设需要将数据聚类成K个簇，其方法为：</p><ul><li><ol><li>首先随机选择K个点，称为聚类中心；</li></ol></li><li><ol><li>对于数据集中的每一个数据，分别计算其到中心点的距离，并将其与距离最近的中心点关联起来，与同一个中心点关联的所有点聚成一类；</li></ol></li><li><ol><li>计算每一个组的平均值，并将中心点移动到平均值的位置；</li></ol></li><li><ol><li>重复2-3直至中心点不再变化。</li></ol></li></ul><p>给定样本集$D=\{x_1, x_2, \ldots,x_n\}$，K均值算法所得簇划分$C=\{C_1, \ldots, C_k\}$, 最小化平方误差为：</p><script type="math/tex; mode=display">E = \sum_{i=1}^k\sum_{x \in C_i}\|x-u_i\|^2</script><p>其中$u_i$为簇$C_i$的中心点。上式其实就是求样本数据中的每一点到其中心点的距离和。</p><h2 id="随机初始化"><a href="#随机初始化" class="headerlink" title="随机初始化"></a>随机初始化</h2><p>随机初始化就是用训练集中随机选择K个数据，作为K个聚类中心。</p><p>问题在于，最后的结果可能停留在一个局部最小值处。</p><p><img src="https://gitee.com/huster_ning/image/raw/master//image/20200705160708.png" srcset="/img/loading.gif" alt=""></p><p>为了解决这一问题，需要多次运行K均值算法，每一次都要重新进行随机初始化，最后选择代价函数最小的结果。</p><h1 id="降维"><a href="#降维" class="headerlink" title="降维"></a>降维</h1><p>降维也是一种无监督学习问题，降维的动机有：数据压缩、数据可视化。</p><h2 id="主成分分析（Principal-Component-Analysis）"><a href="#主成分分析（Principal-Component-Analysis）" class="headerlink" title="主成分分析（Principal Component Analysis）"></a>主成分分析（Principal Component Analysis）</h2>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>无监督学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>支持向量机</title>
    <link href="/2020/07/04/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"/>
    <url>/2020/07/04/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>支持向量机（Support Vector Machine）是类按监督学习方式对数据进行二分类的分类器，对多分类任务要进行专门的推广，其决策边界是对学习样本求解的最大间距超平面。SVM可以通过使用核方法进行非线性分类。</p><h1 id="最大间隔分类器"><a href="#最大间隔分类器" class="headerlink" title="最大间隔分类器"></a>最大间隔分类器</h1><p>对一个数据点进行分类，当超平面离数据点的间隔越大，分类的确信度越大。<br>在样本空间中，划分超平面可通过如下线性方程来描述：</p><script type="math/tex; mode=display">\omega ^ {T}x + b = 0 \tag{1}</script><p>样本空间中任意点x到超平面的距离为：</p><script type="math/tex; mode=display">r = \frac {|\omega^{T}x + b|}{\| \omega \|} \tag{2}</script><p>其中$| \omega |$ 为：</p><script type="math/tex; mode=display">\| \omega \| = \sqrt[2]{\omega_1^2 + \omega_2^2+\ldots+\omega_n^2} \tag{3}</script><p>使用+1和-1来标记样本的正负类。</p><ul><li>对于$y_i$ = +1，有 $\omega^Tx+b$ &gt; 0；</li><li>对于$y_i$ = −1，有$\omega^Tx+b$ &lt; 0.</li></ul><p>令：</p><script type="math/tex; mode=display">\left\{\begin{array}{ll}\boldsymbol{w}^{\mathrm{T}} \boldsymbol{x}_{i}+b \geqslant+1, & y_{i}=+1 \\\boldsymbol{w}^{\mathrm{T}} \boldsymbol{x}_{i}+b \leqslant-1, & y_{i}=-1\end{array}\right. \tag{4}</script><p>下图虚线上的点使上式等号成立，它们被称作“支持向量”。</p><p><img src="https://gitee.com/huster_ning/image/raw/master//image/20200704221839.png" srcset="/img/loading.gif" alt=""></p><p>找到最大间隔的划分超平面，也就是下面的优化问题：</p><script type="math/tex; mode=display">\max \frac {2}{\|\omega\|},s.t. y_i(\omega^{T}x_i+b) \geq 1 \tag{5}</script><p>可以转化为如下问题：</p><script type="math/tex; mode=display">\min \frac {1}{2}\|\omega\|^2,s.t. y_i(\omega^{T}x_i+b) \geq 1 \tag{6}</script><h1 id="软间隔与正则化"><a href="#软间隔与正则化" class="headerlink" title="软间隔与正则化"></a>软间隔与正则化</h1><p>硬间隔是指所有样本都必须划分正确；软间隔则是允许某些样本不满足约束条件。优化目标改写为：</p><script type="math/tex; mode=display">\min_{\omega, b} \frac{1}{2}\|\omega\|^2 + C\sum_{i = 1}^{m}\ell_{0/1}(y_i(\omega^Tx_i + b) - 1) \tag{7}</script><p>其中C &gt; 0是一个常数，$\ell_{0/1}$ 是一个“0/1 损失函数”：</p><script type="math/tex; mode=display">\ell_{0/1} = \left\{\begin{array}{ll}1,if\ z < 0 \\0, otherwise\end{array}\right. \tag{8}</script><p>但该函数非凸、不连续，数学性质不好。常用以下三种替代损失函数：</p><ul><li>hinge损失：$\max(0, 1-z)$；</li><li>指数损失：$e^{-z}$;</li><li>对率损失：$\log(1 + e^{-z})$</li></ul><p>但C不是很大的时候，它可以忽略一些异常点的影响，得到更好的决策边界。</p><ul><li>C较大时，可能会导致过拟合；</li><li>C较小时，可能会导致欠拟合。</li></ul><h1 id="核函数"><a href="#核函数" class="headerlink" title="核函数"></a>核函数</h1><p>如果原始样本空间内并不存在一个能正确划分两类样本的超平面，可以将原始样本空间映射到一个更高维的特征空间，使得样本在这个空间线性可分。使用核函数解决非线性分类问题，可以利用核函数计算新的特征，从而映射到更高维的特征空间。常用的核函数用：</p><p>线性核 ：$k(x_i, x_j) = x_i^Tx_j$ ；</p><p>高斯核 ：$k(x_i, x_j)=exp(-\frac{|x_i-x_j|^2}{2\sigma^2})$，其中$\sigma &gt;0$为高斯核的带宽；</p><p>拉普拉斯核：$k(x_i, x_j) = exp(-\frac{|x_i - x_j|}{\sigma})$，其中$\sigma &gt; 0$.</p><h2 id="使用范例"><a href="#使用范例" class="headerlink" title="使用范例"></a>使用范例</h2><p>从x的各个特征中预先选定三个landmarks $l^{(1)},l^{(2)},l^{(3)}$，则有：</p><script type="math/tex; mode=display">\begin{array}{l}f_1^{(1)} = k(x^{(1)}, l^{(1)})\\f_2^{(1)} = k(x^{(1)}, l^{(2)})\\ f_3^{(1)} = k(x^{(1)}, l^{(3)})\end{array} \tag{9}</script><p>其中$f_1^{(1)},f_2^{(1)},f_3^{(1)}$是利用核函数计算出来的关于$x^{(1)}$的新特征。以此类推可以计算$f^{(2)}, \ldots, f^{(n)}$.则决策边界可以表示为：</p><script type="math/tex; mode=display">\omega_0 + \omega_1 f_1 + \omega_2 f_2 + \omega_3 f_3 = 0 \tag{10}</script>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>监督学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux用户</title>
    <link href="/2020/07/04/Linux%E7%94%A8%E6%88%B7/"/>
    <url>/2020/07/04/Linux%E7%94%A8%E6%88%B7/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h1><h2 id="passwd文件"><a href="#passwd文件" class="headerlink" title="passwd文件"></a>passwd文件</h2><p>passwd文件位于<code>/etc/passwd</code>, 各字段含义如下：</p><ul><li>1、账户名称：用来对应UID</li><li>2、密码：早起Unix系统的密码就是防止这个字段上，但是英文这个档案的特性是所有程序都能读取，容易造成密码数据被窃取应此后来就将这个字段的密码数据放到了/etc/shadow中了，所以这里使用【X】，</li><li>3、UID：用户ID，当UID为0时，用户拥有root权限，但该用户不一定是root；1-499保留给系统使用的ID；500~ ，一般使用者。</li><li>4、GID：这个与/etc/group有关！其实/etc/group的观念与/etc/passwd差不多，应用来规范组名</li><li>5、用户信息说明栏：</li><li>6、家目录：root的家目录在/root，所以当root登陆的之后，就会立刻跑到/root目录里头，如果坏、这个账号需要使用特别大的空间，就可以对这个字段进行修改，已移动到其他同硬盘。默认的用户家目录在/home/youIdname, home目录即<code>~</code>。</li><li>7、Shell:定义用户登陆系统使用什么shell，这里需要注意，有一个shell可以用来特带成让账户无法取得shell环境的登陆动作！那就是/sbin/nologin这个特殊东西，也可以用来制作pop邮件账号者的数据。<div class="hljs"><pre><code class="hljs undefined"><span class="hljs-symbol">:/etc</span><span class="hljs-variable">$ </span>cat /etc/passwd<span class="hljs-symbol">root:</span><span class="hljs-symbol">x:</span><span class="hljs-number">0</span><span class="hljs-symbol">:</span><span class="hljs-number">0</span><span class="hljs-symbol">:root</span><span class="hljs-symbol">:/root</span><span class="hljs-symbol">:/bin/bash</span><span class="hljs-symbol">xinger:</span><span class="hljs-symbol">x:</span><span class="hljs-number">1000</span><span class="hljs-symbol">:</span><span class="hljs-number">1000</span><span class="hljs-symbol">:</span>,,,<span class="hljs-symbol">:/home/xinger</span><span class="hljs-symbol">:/bin/bash</span><span class="hljs-symbol">mongodb:</span><span class="hljs-symbol">x:</span><span class="hljs-number">111</span><span class="hljs-symbol">:</span><span class="hljs-number">116</span><span class="hljs-symbol">:</span><span class="hljs-symbol">:/var/lib/mongodb</span><span class="hljs-symbol">:/usr/sbin/nologin</span><span class="hljs-symbol">redis:</span><span class="hljs-symbol">x:</span><span class="hljs-number">112</span><span class="hljs-symbol">:</span><span class="hljs-number">117</span><span class="hljs-symbol">:</span><span class="hljs-symbol">:/var/lib/redis</span><span class="hljs-symbol">:/usr/sbin/nologin</span></code></pre></div></li></ul><h3 id="禁止用户shell登录权限"><a href="#禁止用户shell登录权限" class="headerlink" title="禁止用户shell登录权限"></a>禁止用户shell登录权限</h3><p>比如禁止git用户shell登录权限</p><div class="hljs"><pre><code class="hljs undefined">- <span class="hljs-symbol">git:</span><span class="hljs-symbol">x:</span><span class="hljs-number">1001</span><span class="hljs-symbol">:</span><span class="hljs-number">1001</span><span class="hljs-symbol">:</span>,,,<span class="hljs-symbol">:/home/git</span><span class="hljs-symbol">:/bin/bash</span><span class="hljs-comment"># 修改成如下</span>+ <span class="hljs-symbol">git:</span><span class="hljs-symbol">x:</span><span class="hljs-number">1001</span><span class="hljs-symbol">:</span><span class="hljs-number">1001</span><span class="hljs-symbol">:</span>,,,<span class="hljs-symbol">:/home/git</span><span class="hljs-symbol">:/usr/bin/git-shell</span></code></pre></div><h2 id="用户相关操作"><a href="#用户相关操作" class="headerlink" title="用户相关操作"></a>用户相关操作</h2><h3 id="新建用户"><a href="#新建用户" class="headerlink" title="新建用户"></a>新建用户</h3><p>有以下两种方式：<br><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">adduser </span>username<span class="hljs-symbol">useradd</span> username</code></pre></div></p><h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><p>对应不同的创建有不同的删除方式：<br><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attribute">deluser usernameuserdel username</span></code></pre></div></p><h3 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h3><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attribute">su username</span></code></pre></div><h3 id="改变文件用户"><a href="#改变文件用户" class="headerlink" title="改变文件用户"></a>改变文件用户</h3><div class="hljs"><pre><code class="hljs undefined">chown -R username <span class="hljs-keyword">dir </span><span class="hljs-comment"># 用户</span>chgrp -R grpname <span class="hljs-keyword">dir </span><span class="hljs-comment"># 用户组</span></code></pre></div><h3 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h3><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attribute">passwd</span> username <span class="hljs-comment"># 修改密码</span>passwd username -d <span class="hljs-comment"># 删除密码</span></code></pre></div><h2 id="etc-sudoers文件"><a href="#etc-sudoers文件" class="headerlink" title="/etc/sudoers文件"></a>/etc/sudoers文件</h2><p>修改sudoers文件让用户获得sudo的使用权, 避免出现如下错误：</p><blockquote><p>xinger is not in the sudoers file.  This incident will be reported.</p></blockquote><p>比如创建了一个git用户，sudoers文件中添加<code>git   ALL=(ALL) ALL</code>让git用户获得sudo使用权。<br><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-comment"># User privilege specification</span><span class="hljs-attribute">root</span>    <span class="hljs-literal">ALL</span>=(<span class="hljs-literal">ALL</span>:<span class="hljs-literal">ALL</span>) <span class="hljs-literal">ALL</span><span class="hljs-comment"># </span><span class="hljs-attribute">git</span>     <span class="hljs-literal">ALL</span>=(<span class="hljs-literal">ALL</span>) <span class="hljs-literal">ALL</span></code></pre></div></p><ul><li>第一个ALL是指网络中的主机，我们后面把它改成了主机名，它指明jack可以在此主机上执行后面的命令。</li><li>第二个括号里的ALL是指目标用户，也就是以谁的身份去执行命令。</li><li>最后一个ALL当然就是指命令名了。</li></ul><p>修改sudoers文件需要修改文件的读写权限, 注意要在在修改后将权限改回：<br><div class="hljs"><pre><code class="hljs undefined">sudo chmod +<span class="hljs-number">777</span> <span class="hljs-regexp">/etc/</span>sudoers<span class="hljs-comment"># 修改后将权限改回</span>sudo chmod <span class="hljs-number">440</span> <span class="hljs-regexp">/etc/</span>sudoers</code></pre></div></p><h1 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h1><ul><li>Linux文件的权限类型一般包括读、写、执行，对应字母为r、w、x，对应数字为4、2、1。对于一个文件夹而言，可写就意味着可以在这个文件夹下创建文件或文件夹；</li><li>Linux下权限的粒度分为拥有者、群组、其他组三种；</li><li>使用<code>chmod</code>命令修改文件权限，使用<code>chown</code>修改拥有者或群组，使用<code>chgrp</code>修改群组。</li><li>chown：一般来说，这个指令只有是由系统管理者(root)所使用，一般使用者没有权限可以改变别人的文件拥有者，也没有权限把自己的文件拥有者改设为别人。只有系统管理者(root)才有这样的权限。</li></ul><h2 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h2><h3 id="一般使用"><a href="#一般使用" class="headerlink" title="一般使用"></a>一般使用</h3><div class="hljs"><pre><code class="hljs shell">chmod [ugoa] [[+-=][rwx]]其中：[ugoa] u表示拥有者，g表示拥有群组，o表示其他，a表示全部[+-=] + 表示增加权限，- 表示取消权限，= 表示唯一设定权限。[rwxX] r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该档案是个子目录或者该档案已经被设定过为可执行。</code></pre></div><h3 id="数字权限"><a href="#数字权限" class="headerlink" title="数字权限"></a>数字权限</h3><p>r = 4, w = 2, x = 1.</p><ul><li><p>rwx则表示为：4 + 2 + 1 = 7；</p></li><li><p>r—则表示为：4 + 0 + 0 = 4；</p></li></ul><p>如果设置所有人都有rwx权限, 则用数字表示的权限为777，使用如下命令更改权限：</p><div class="hljs"><pre><code class="hljs undefined">chmod <span class="hljs-number">777</span> <span class="hljs-built_in">file</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习基础</title>
    <link href="/2020/07/03/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/07/03/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-监督学习和非监督学习"><a href="#1-监督学习和非监督学习" class="headerlink" title="1. 监督学习和非监督学习"></a>1. 监督学习和非监督学习</h1><h2 id="1-1-监督学习"><a href="#1-1-监督学习" class="headerlink" title="1.1 监督学习"></a>1.1 监督学习</h2><p>定义：监督学习中，训练的数据集中既有特征（feature）又有标签（label），通过训练，可以让机器找到特征与标签之间的联系。</p><p>监督学习分为回归（Regression）、分类（Classification）</p><h3 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h3><p>回归问题是针对连续型变量的。</p><h4 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h4><h5 id="（1）单变量线性回归"><a href="#（1）单变量线性回归" class="headerlink" title="（1）单变量线性回归"></a>（1）单变量线性回归</h5><p>单变量线性回归只给出一个特征，比如预测房屋价格问题，样本中只给出房屋尺寸这一个特征，通过回归算法，找出房价与房屋尺寸的线性关系。</p><script type="math/tex; mode=display">h_{\theta}(x) = {\theta}_{0} + {\theta}_{1} x</script><h5 id="（2）多变量线性回归"><a href="#（2）多变量线性回归" class="headerlink" title="（2）多变量线性回归"></a>（2）多变量线性回归</h5><p>多变量线性回归提供多个特征。比如预测房屋价格，给出房屋尺寸、房屋楼层等特征。<br>代价函数：</p><script type="math/tex; mode=display">J({\theta}_0, {\theta}_1, \ldots, {\theta}_n) = \frac {1}{2m} {\sum}_{i=1}^{m}(h_{\theta}(x^{(i)}) - y^{(i)})^2</script><p>其中：</p><script type="math/tex; mode=display">h_{\theta}(x) = {\theta}_0 + {\theta}_{1}x + ··· + {\theta}_{n}x</script><h4 id="逻辑回归（Logistics-Regression）"><a href="#逻辑回归（Logistics-Regression）" class="headerlink" title="逻辑回归（Logistics Regression）"></a>逻辑回归（Logistics Regression）</h4><p>适用于二分类问题，逻辑回归的输出是如下形式：</p><script type="math/tex; mode=display">a = \sigma(\omega^{T}x + b)</script><p>$\sigma()$是指<code>sigmoid</code>函数：</p><script type="math/tex; mode=display">\sigma(x) = \frac{1}{1 + e^{-x}}</script><p>使用<code>sigmoid</code>函数将线性函数转变成非线性，这也就是逻辑回归与线性回归的根本区别所在。</p><p>逻辑回归使用二分类交叉熵函数作为代价函数，使用梯度下降法进行优化。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>分类是针对离散型变量的。</p><h2 id="1-2-无监督学习"><a href="#1-2-无监督学习" class="headerlink" title="1.2 无监督学习"></a>1.2 无监督学习</h2><p>定义：训练数据集中没有标签，与监督学习相比更像是自学。</p><h1 id="2-代价函数"><a href="#2-代价函数" class="headerlink" title="2. 代价函数"></a>2. 代价函数</h1><p>机器学习中，训练模型的过程就是优化代价函数的过程。一个好的代价函数需要满足两个基本的要求：</p><ul><li>能够评价模型的准确性；</li><li>对参数可微。</li></ul><p>代价函数与损失函数的区别：损失函数是计算单个样本的损失值，而代价函数是计算总代价。</p><h2 id="2-1-均方误差"><a href="#2-1-均方误差" class="headerlink" title="2.1 均方误差"></a>2.1 均方误差</h2><p>线性回归中，常使用均方误差（Mean squared error）作为代价函数。</p><script type="math/tex; mode=display">J({\theta}_0, {\theta}_1, \ldots, {\theta}_n) = \frac {1}{2m} {\sum}_{i=1}^{m}(h_{\theta}(x^{(i)}) - y^{(i)})^2</script><h2 id="2-2-交叉熵"><a href="#2-2-交叉熵" class="headerlink" title="2.2 交叉熵"></a>2.2 交叉熵</h2><p>交叉熵代价函数常常用于分类问题，分类问题又分为二分类和多分类。</p><h3 id="二分类"><a href="#二分类" class="headerlink" title="二分类"></a>二分类</h3><p>逻辑回归是一个典型的二分类模型，使用如下代价函数进行参数优化。</p><script type="math/tex; mode=display">J({y}, {a}) = - \frac{1}{m}{\sum}_{i=1}^{m}(y^{(i)}\log(a^{(i)}) + (1-y^{(i)})\log(1-a^{(i)}))</script><p>其中y是指实际结果，a是指预期结果。</p><h3 id="多分类"><a href="#多分类" class="headerlink" title="多分类"></a>多分类</h3><script type="math/tex; mode=display">J(y, a) = - \frac{1}{m} \sum_{i=1}^{m}y^{(i)}\log(a^{(i)})</script><p>手写数字识别是一个多分类问题（识别0-9共10种数字），可以对labels进行one-hot编码，one-hot编码是指正确解的标签为1，其余为0，比如一个手写数字样本标签为3，则编码表示为$[0,0,0, 1, 0, 0, 0, 0, 0, 0]$, 如果计算的预期结果为$[2.2, 3.1, 1.2, 4.4, 0.1, 0.9, 3.5, 0.5, 0.9, 0.1]$，则单个样本的损失值为$-log(4.4)$</p><h1 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h1><p>训练神经网络的过程：</p><p>1） 参数的随机初始化；</p><p>2） 正向传播；</p><p>3） 计算代价；</p><p>4）反向传播计算所有偏导数；</p><p>5） 利用数值检验方法检验这些偏导数；</p><p>6）使用优化来最小化代价函数。</p><h2 id="随机初始化"><a href="#随机初始化" class="headerlink" title="随机初始化"></a>随机初始化</h2><p>参数初始化一般采用随机初始化，而不应该将所有参数都初始化为0，对于逻辑回归来说，全部初始化为0是可行的，因为逻辑回归是一层的神经网络，且只有一个神经元。对于复杂的神经网络来说，如果参数全部初始化为0，则对于同一层的所有神经元而言，其计算结果都是一样的，反向传播求的梯度也是一样的。</p><h2 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h2><p><strong>反向传播</strong>（Back Propagation）是“误差反向传播”的简称，是一种与<a href="https://zh.wikipedia.org/wiki/最优化" target="_blank" rel="noopener">最优化方法</a>（如<a href="https://zh.wikipedia.org/wiki/梯度下降法" target="_blank" rel="noopener">梯度下降法</a>）结合使用的，用来训练<a href="https://zh.wikipedia.org/wiki/人工神经网络" target="_blank" rel="noopener">人工神经网络</a>的常见方法。该方法使用链式法则对网络中所有权重计算损失函数的梯度。这个梯度会反馈给最优化方法，用来更新权值以最小化损失函数。</p><p>反向传播算法（BP 算法）主要由两个阶段组成：激励传播与权重更新。</p><h3 id="第1阶段：激励传播"><a href="#第1阶段：激励传播" class="headerlink" title="第1阶段：激励传播"></a>第1阶段：激励传播</h3><p>每次迭代中的传播环节包含两步：</p><ol><li>（前向传播阶段）将训练输入送入网络以获得激励响应；</li><li>（反向传播阶段）将激励响应同训练输入对应的目标输出求差，从而获得输出层和隐藏层的响应误差。</li></ol><h3 id="第2阶段：权重更新"><a href="#第2阶段：权重更新" class="headerlink" title="第2阶段：权重更新"></a>第2阶段：权重更新</h3><p>对于每个突触上的权重，按照以下步骤进行更新：</p><ol><li>将输入激励和响应误差相乘，从而获得权重的梯度；</li><li>将这个梯度乘上一个比例并取反后加到权重上。</li></ol><p>这个比例（百分比）将会影响到训练过程的速度和效果，因此成为<strong>“学习率”</strong>。梯度的方向指明了误差扩大的方向，因此在更新权重的时候需要对其取反，从而减小权重引起的误差。</p><p>第 1 和第 2 阶段可以反复循环迭代，直到网络对输入的响应达到满意的预定的目标范围为止。</p><h2 id="梯度检验"><a href="#梯度检验" class="headerlink" title="梯度检验"></a>梯度检验</h2><p>通过估计梯度值来检验计算得到的导数值是否是正确的。下面对$\theta_1$进行检验：</p><script type="math/tex; mode=display">\frac {\partial {J}}{\partial \theta_1} = \frac {J(\theta_1+\epsilon, \theta_2,\ldots, \theta_n)-J(\theta_1-\epsilon, \theta_2,\ldots, \theta_n)}{2\epsilon}</script><p>其中$\epsilon$是一个非常小的常量。将上式计算得到的梯度与反向传播的梯度进行比较，若相差很小，则梯度是正确的。</p><h1 id="应用机器学习的建议"><a href="#应用机器学习的建议" class="headerlink" title="应用机器学习的建议"></a>应用机器学习的建议</h1><h2 id="模型选择"><a href="#模型选择" class="headerlink" title="模型选择"></a>模型选择</h2><p>使用<strong>验证集</strong>来选择模型，验证集并不参与学习参数的确定，而是用来选择超参数，比如多项式次数、网络层数、网络节点数、迭代次数、学习率等。</p><ul><li>训练集：用来训练模型内的参数的数据集；</li><li>验证集：用来选择模型；</li><li>测试集：用来评价模型泛化能力。训练过程不能使用测试集。</li></ul><h3 id="交叉验证（cross-validation）"><a href="#交叉验证（cross-validation）" class="headerlink" title="交叉验证（cross validation）"></a>交叉验证（cross validation）</h3><p>交叉验证的做法就是先将数据集分出一个测试集，然后将剩下的数据分为比较均等不相交的k份，然后选择其中一份验证，另外的k-1份进行训练，最后求得error的平均值作为最终的评价。</p><p><img src="https://gitee.com/huster_ning/image/raw/master//image/20200703174015.png" srcset="/img/loading.gif" alt=""></p><h1 id="过拟合与欠拟合"><a href="#过拟合与欠拟合" class="headerlink" title="过拟合与欠拟合"></a>过拟合与欠拟合</h1><p><strong>过拟合（Over-Fitting）</strong></p><p>在训练集上误差小，但在测试集上误差大，我们将这种情况称为高方差（high variance）</p><p><strong>欠拟合（Under-Fitting）</strong></p><p>在训练集上训练结果不好，准确率不高，我们将这种情况称为高偏差（high bias), 也叫欠拟合。</p><p><img src="https://gitee.com/huster_ning/image/raw/master//image/20200702165139.png" srcset="/img/loading.gif" alt=""></p><h2 id="偏差与方差"><a href="#偏差与方差" class="headerlink" title="偏差与方差"></a>偏差与方差</h2><p><strong>偏差：</strong>描述的是预测值（估计值）的期望与真实值之间的差距。偏差越大，越偏离真实数据，如下图第二行所示。</p><p><strong>方差：</strong>描述的是预测值的变化范围，离散程度，也就是离其期望值的距离。方差越大，数据的分布越分散，如下图右列所示。</p><p><img src="https://gitee.com/huster_ning/image/raw/master//image/20200702170430.png" srcset="/img/loading.gif" alt=""></p><p>通过将训练集和交叉验证集的代价函数误差与多项式的次数绘制在一张图表上分析偏差和方差问题。</p><ul><li>训练集误差较大，且验证集误差与训练集误差相近：高偏差；</li><li>验证集误差远大于训练集误差：高方差。</li></ul><p><img src="https://gitee.com/huster_ning/image/raw/master//image/20200703175526.png" srcset="/img/loading.gif" alt=""></p><h2 id="如何防止过拟合"><a href="#如何防止过拟合" class="headerlink" title="如何防止过拟合"></a>如何防止过拟合</h2><ul><li>增加数据集</li><li>减少不能帮助正确预测的特征</li><li>正则化，增加正则化程度 $\lambda$</li><li>Dropout</li><li>Early Stopping</li><li>简化模型</li><li>增加噪声</li><li>Bagging</li><li>贝叶斯方法</li><li>决策树剪枝</li><li>集成方法，随机森林</li><li>Batch Normalization</li></ul><h3 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h3><p>正则化就是对最小化经验误差函数上加约束，正则化项一般是模型复杂度的单调递增函数，模型越复杂，正则化值就越大。比如，正则化项可以是模型参数向量的范数。</p><h4 id="范数"><a href="#范数" class="headerlink" title="范数"></a>范数</h4><p>$l_p$范数定义为：    </p><script type="math/tex; mode=display">\|{x}\|_{p}=\sqrt[p]{\sum_{i}\left|x_{i}\right|^{p}}</script><p>其中$x$ 表示一个向量。</p><h5 id="l-0-范数"><a href="#l-0-范数" class="headerlink" title="$l_0$范数"></a>$l_0$范数</h5><p>$l_0$范数表示向量中非0元素的个数，其优化模型是一个NP难问题，难以求解。</p><h5 id="l-1-范数"><a href="#l-1-范数" class="headerlink" title="$l_1$范数"></a>$l_1$范数</h5><p>$l_1$范数等于向量中所有哦元素绝对值之和。</p><script type="math/tex; mode=display">\|{x}\|_{1}=\sum_{i}|x_{i}|</script><h5 id="l-2-范数"><a href="#l-2-范数" class="headerlink" title="$l_2$范数"></a>$l_2$范数</h5><p>$l_2$范数即欧氏距离。</p><script type="math/tex; mode=display">\|{x}\|_{2}=\sqrt[2]{\sum_{i}\left|x_{i}\right|^{2}}</script><h4 id="L-1-和-L-2-正则化"><a href="#L-1-和-L-2-正则化" class="headerlink" title="$L_1$和$L_2$正则化"></a>$L_1$和$L_2$正则化</h4><p>$L_1$正则化：正则化项是参数向量的$L_1$范数。</p><script type="math/tex; mode=display">J(\omega, b) = \frac{1}{m} \sum_{i=1}^{m}L(y,a) + \frac {\lambda} {m} \sum \omega</script><p>$L_2$正则化：正则化项是参数向量的$L_2$范数的平方。</p><script type="math/tex; mode=display">J(\omega, b) = \frac{1}{m} \sum_{i=1}^{m}L(y,a) + \frac {\lambda} {2m} \sum \omega ^2</script><p>注意：可以不正则化参数$b$，$\frac{\lambda}{2m}$只是一个常数项，除以2是为了后面求导方便。</p><h2 id="如何防止欠拟合"><a href="#如何防止欠拟合" class="headerlink" title="如何防止欠拟合"></a>如何防止欠拟合</h2><ul><li>添加新特征</li><li>添加多项式特征</li><li>减少正则化参数, 减少正则化程度 $\lambda$</li><li>增加网络复杂度</li><li>使用集成学习方法，如Bagging</li></ul><h1 id="符号约定"><a href="#符号约定" class="headerlink" title="符号约定"></a>符号约定</h1><h2 id="数据标记与上下标"><a href="#数据标记与上下标" class="headerlink" title="数据标记与上下标"></a>数据标记与上下标</h2><ul><li>上标： $^{(i)}$ 表示第i个样本；</li><li>上标：$^{[i]}$ 代表第i层；</li><li>m: 数据集的样本数； </li></ul>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LaTeX数学公式</title>
    <link href="/2020/07/03/LaTeX%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"/>
    <url>/2020/07/03/LaTeX%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="常用符号"><a href="#常用符号" class="headerlink" title="常用符号"></a>常用符号</h2><div class="table-container"><table><thead><tr><th>符号</th><th>示例</th><th>显示</th></tr></thead><tbody><tr><td>偏导</td><td>\partial y</td><td>$\partial y$</td></tr><tr><td>上下标</td><td>S=a_{1}^2+a_{2}^2+a_{3}^2</td><td>$S=a_{1}^2+a_{2}^2+a_{3}^2$</td></tr><tr><td>分数</td><td>\frac{1}{3}</td><td>$\frac{1}{3}$</td></tr><tr><td>开方</td><td>\sqrt[3]{X}</td><td>$\sqrt[3]{X}$</td></tr><tr><td></td><td>\bar x</td><td>$\bar x$</td></tr><tr><td>求导</td><td>\mathrm{d}y</td><td>$\mathrm{d}y$</td></tr><tr><td>向量</td><td>\vec x</td><td>$\vec{x}$</td></tr><tr><td>X帽</td><td>\hat X 或者\widehat X</td><td>$\hat X$ 或者$\widehat X$</td></tr><tr><td>大括号</td><td><code>\left\{\begin{array}{l}1\\0\end{array}\right.</code>，用法：<code>\begin{array}[{垂直对齐}]{（列格式说明）} &lt;表项&gt; &amp; &lt;表项&gt; &amp;...&amp; \\ \end{array}</code>, 列格式说明有：l（左对齐）、r（右对齐）、c（中间对齐）三种</td><td>$\left\{\begin{array}{l}1\\0\end{array}\right.$</td></tr></tbody></table></div><h2 id="其他字符"><a href="#其他字符" class="headerlink" title="其他字符"></a>其他字符</h2><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><div class="table-container"><table><thead><tr><th>代码</th><th>符号</th></tr></thead><tbody><tr><td>\pm</td><td>$\pm$</td></tr><tr><td>\times</td><td>$\times$</td></tr><tr><td>\div</td><td>$\div$</td></tr><tr><td>\mid</td><td>$\mid$</td></tr><tr><td>\nmid</td><td>$\nmid$</td></tr><tr><td>\cdot</td><td>$\cdot$</td></tr><tr><td>\ldots</td><td>$\ldots$</td></tr><tr><td>\circ</td><td>$\circ$</td></tr><tr><td>\ast</td><td>$\ast$</td></tr><tr><td>\bigodot</td><td>$\bigodot$</td></tr><tr><td>\bigotimes</td><td>$\bigotimes$</td></tr><tr><td>\bigoplus</td><td>$\bigoplus$</td></tr><tr><td>\leq</td><td>$\leq$</td></tr><tr><td>\geq</td><td>$\geq$</td></tr><tr><td>\neq</td><td>$\neq$</td></tr><tr><td>\approx</td><td>$\approx$</td></tr><tr><td>\equiv</td><td>$\equiv$</td></tr><tr><td>\sum</td><td>$\sum$</td></tr><tr><td>\prod</td><td>$\prod$</td></tr></tbody></table></div><h3 id="微积分运算符"><a href="#微积分运算符" class="headerlink" title="微积分运算符"></a>微积分运算符</h3><div class="table-container"><table><thead><tr><th>代码</th><th>符号</th></tr></thead><tbody><tr><td>\prime</td><td>$\prime$</td></tr><tr><td>\int</td><td>$\int$</td></tr><tr><td>\iint</td><td>$\iint$</td></tr><tr><td>\iiint</td><td>$\iiint$</td></tr><tr><td>\oint</td><td>$\oint$</td></tr><tr><td>\lim</td><td>$\lim$</td></tr><tr><td>\infty</td><td>$\infty$</td></tr><tr><td>\nabla</td><td>$\nabla$</td></tr><tr><td>\mathrm{d}</td><td>$\mathrm{d}$</td></tr></tbody></table></div><h3 id="集合运算符"><a href="#集合运算符" class="headerlink" title="集合运算符"></a>集合运算符</h3><div class="table-container"><table><thead><tr><th>代码</th><th>符号</th></tr></thead><tbody><tr><td>\emptyset</td><td>$\emptyset$</td></tr><tr><td>\in</td><td>$\in$</td></tr><tr><td>\notin</td><td>$\notin$</td></tr><tr><td>\subset</td><td>$\subset$</td></tr><tr><td>\subseteq</td><td>$\subseteq$</td></tr><tr><td>\supseteq</td><td>$\supseteq$</td></tr></tbody></table></div><h3 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h3><div class="table-container"><table><thead><tr><th>代码</th><th>大写</th><th>代码</th><th>小写</th></tr></thead><tbody><tr><td>A</td><td>$A$</td><td>\alpha</td><td>$\alpha$</td></tr><tr><td>B</td><td>$B$</td><td>\beta</td><td>$\beta$</td></tr><tr><td>\Gamma</td><td>$\Gamma$</td><td>\gamma</td><td>$\gamma$</td></tr><tr><td>\Delta</td><td>$\Delta$</td><td>\delta</td><td>$\delta$</td></tr><tr><td>E</td><td>$E$</td><td>\epsilon</td><td>$\epsilon$</td></tr><tr><td>Z</td><td>$Z$</td><td>\zeta</td><td>$\zeta$</td></tr><tr><td>H</td><td>$H$</td><td>\eta</td><td>$\eta$</td></tr><tr><td>\Theta</td><td>$\Theta$</td><td>\theta</td><td>$\theta$</td></tr><tr><td>I</td><td>$I$</td><td>\iota</td><td>$\iota$</td></tr><tr><td>K</td><td>$K$</td><td>\kappa</td><td>$\kappa$</td></tr><tr><td>Lambda</td><td>$\Lambda$</td><td>\lambda</td><td>$\lambda$</td></tr><tr><td>M</td><td>$M$</td><td>\mu</td><td>$\mu$</td></tr><tr><td>N</td><td>$N$</td><td>\nu</td><td>$\nu$</td></tr><tr><td>Xi</td><td>$Xi$</td><td>\xi</td><td>$\xi$</td></tr><tr><td>O</td><td>$O$</td><td>\omicron</td><td>$\omicron$</td></tr><tr><td>\Pi</td><td>$\Pi$</td><td>\pi</td><td>$\pi$</td></tr><tr><td>P</td><td>$P$</td><td>\rho</td><td>$\rho$</td></tr><tr><td>\Sigma</td><td>$\Sigma$</td><td>\sigma</td><td>$\sigma$</td></tr><tr><td>T</td><td>$T$</td><td>\tau</td><td>$\tau$</td></tr><tr><td>\Upsilon</td><td>$\Upsilon$</td><td>\upsilon</td><td>$\upsilon$</td></tr><tr><td>\Phi</td><td>$\Phi$</td><td>\phi</td><td>$\phi$</td></tr><tr><td>X</td><td>$X$</td><td>\chi</td><td>$\chi$</td></tr><tr><td>\Psi</td><td>$\Psi$</td><td>\psi</td><td>$\psi$</td></tr><tr><td>\Omega</td><td>$\Omega$</td><td>\omega</td><td>$\omega$</td></tr></tbody></table></div>]]></content>
    
    
    <categories>
      
      <category>LaTeX</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LaTex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>softmax回归实现手写数字识别</title>
    <link href="/2020/07/02/softmax%E5%9B%9E%E5%BD%92%E5%AE%9E%E7%8E%B0%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/"/>
    <url>/2020/07/02/softmax%E5%9B%9E%E5%BD%92%E5%AE%9E%E7%8E%B0%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h1><p>如下图所示，构建了一个3层的神经网络（不包括输入层），第一个隐藏层包括128个神经元，第二个隐藏层包括64个神经元，输出层包括10个神经元。隐藏层中每个神经元进行两项运算：先进行线性运算，然后使用<code>tanh</code>激励函数；输出层也是先进行线性运算，但激励函数使用的是<code>softmax</code>。</p><p><img src="http://image.ningxin.site/神经网络模型图.png" srcset="/img/loading.gif" alt="网络结构图" style="zoom: 67%;"></p><h1 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h1><p>使用MNIST数据集，都是<code>28 x 28</code>大小的图片，一共有60000个训练样本和10000个测试样本。</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">import</span> struct<span class="hljs-comment"># 训练集文件</span>train_images_idx3_ubyte_file = <span class="hljs-string">'data/MNIST/raw/train-images-idx3-ubyte'</span><span class="hljs-comment"># 训练集标签文件</span>train_labels_idx1_ubyte_file = <span class="hljs-string">'data/MNIST/raw/train-labels-idx1-ubyte'</span><span class="hljs-comment"># 测试集文件</span>test_images_idx3_ubyte_file = <span class="hljs-string">'data/MNIST/raw/t10k-images-idx3-ubyte'</span><span class="hljs-comment"># 测试集标签文件</span>test_labels_idx1_ubyte_file = <span class="hljs-string">'data/MNIST/raw/t10k-labels-idx1-ubyte'</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decode_idx3_ubyte</span><span class="hljs-params">(idx3_ubyte_file)</span>:</span>    <span class="hljs-string">"""    解析idx3文件的通用函数    :param idx3_ubyte_file: idx3文件路径    :return: 数据集    """</span>    <span class="hljs-comment"># 读取二进制数据</span>    bin_data = open(idx3_ubyte_file, <span class="hljs-string">'rb'</span>).read()    <span class="hljs-comment"># 解析文件头信息，依次为魔数、图片数量、每张图片高、每张图片宽</span>    offset = <span class="hljs-number">0</span>    fmt_header = <span class="hljs-string">'&gt;iiii'</span>  <span class="hljs-comment"># 因为数据结构中前4行的数据类型都是32位整型，所以采用i格式，但我们需要读取前4行数据，所以需要4个i。我们后面会看到标签集中，只使用2个ii。</span>    magic_number, num_images, num_rows, num_cols = struct.unpack_from(fmt_header, bin_data, offset)    <span class="hljs-comment"># print('魔数:%d, 图片数量: %d张, 图片大小: %d*%d' % (magic_number, num_images, num_rows, num_cols))</span>    <span class="hljs-comment"># 解析数据集</span>    image_size = num_rows * num_cols    offset += struct.calcsize(fmt_header)  <span class="hljs-comment"># 获得数据在缓存中的指针位置，从前面介绍的数据结构可以看出，读取了前4行之后，指针位置（即偏移位置offset）指向0016。</span>    print(offset)    fmt_image = <span class="hljs-string">'&gt;'</span> + str(        image_size) + <span class="hljs-string">'B'</span>  <span class="hljs-comment"># 图像数据像素值的类型为unsigned char型，对应的format格式为B。这里还有加上图像大小784，是为了读取784个B格式数据，如果没有则只会读取一个值（即一副图像中的一个像素值）</span>    print(fmt_image, offset, struct.calcsize(fmt_image))    images = np.empty((num_images, num_rows, num_cols))    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(num_images):        images[i] = np.array(struct.unpack_from(fmt_image, bin_data, offset)).reshape((num_rows, num_cols))        offset += struct.calcsize(fmt_image)    <span class="hljs-keyword">return</span> images<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decode_idx1_ubyte</span><span class="hljs-params">(idx1_ubyte_file)</span>:</span>    <span class="hljs-string">"""    解析idx1文件的通用函数    :param idx1_ubyte_file: idx1文件路径    :return: 数据集    """</span>    <span class="hljs-comment"># 读取二进制数据</span>    bin_data = open(idx1_ubyte_file, <span class="hljs-string">'rb'</span>).read()    <span class="hljs-comment"># 解析文件头信息，依次为魔数和标签数</span>    offset = <span class="hljs-number">0</span>    fmt_header = <span class="hljs-string">'&gt;ii'</span>    magic_number, num_images = struct.unpack_from(fmt_header, bin_data, offset)    <span class="hljs-comment"># print('魔数:%d, 图片数量: %d张' % (magic_number, num_images))</span>    <span class="hljs-comment"># 解析数据集</span>    offset += struct.calcsize(fmt_header)    fmt_image = <span class="hljs-string">'&gt;B'</span>    labels = np.empty(num_images, dtype=np.int64)    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(num_images):        <span class="hljs-comment"># if (i + 1) % 10000 == 0:</span>        <span class="hljs-comment">#     print('已解析 %d' % (i + 1) + '张')</span>        labels[i] = struct.unpack_from(fmt_image, bin_data, offset)[<span class="hljs-number">0</span>]        offset += struct.calcsize(fmt_image)    <span class="hljs-keyword">return</span> labels<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">load_train_images</span><span class="hljs-params">(idx_ubyte_file=train_images_idx3_ubyte_file)</span>:</span>    <span class="hljs-keyword">return</span> decode_idx3_ubyte(idx_ubyte_file)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">load_train_labels</span><span class="hljs-params">(idx_ubyte_file=train_labels_idx1_ubyte_file)</span>:</span>    <span class="hljs-keyword">return</span> decode_idx1_ubyte(idx_ubyte_file)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">load_test_images</span><span class="hljs-params">(idx_ubyte_file=test_images_idx3_ubyte_file)</span>:</span>    <span class="hljs-keyword">return</span> decode_idx3_ubyte(idx_ubyte_file)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">load_test_labels</span><span class="hljs-params">(idx_ubyte_file=test_labels_idx1_ubyte_file)</span>:</span>    <span class="hljs-keyword">return</span> decode_idx1_ubyte(idx_ubyte_file)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">init_data</span><span class="hljs-params">()</span>:</span>    train_img = load_train_images()    train_img = train_img.reshape(train_img.shape[<span class="hljs-number">0</span>], train_img.shape[<span class="hljs-number">1</span>] * train_img.shape[<span class="hljs-number">2</span>]).T / <span class="hljs-number">255</span>    test_img = load_test_images()    test_img = test_img.reshape(test_img.shape[<span class="hljs-number">0</span>], test_img.shape[<span class="hljs-number">1</span>] * test_img.shape[<span class="hljs-number">2</span>]).T / <span class="hljs-number">255</span>    train_label = load_train_labels()    test_label = load_test_labels()    <span class="hljs-keyword">return</span> train_img, train_label, test_img, test_label</code></pre></div><p>数据处理后训练样本和测试样本的维度：<br><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attribute">train_img</span>: (784, 60000)<span class="hljs-attribute">train_label</span>: (60000, )<span class="avrasm"><span class="hljs-symbol">test_img:</span> (<span class="hljs-number">784</span>, <span class="hljs-number">10000</span>)<span class="hljs-symbol">test_label:</span> (<span class="hljs-number">10000</span>, )</span></code></pre></div></p><h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><p>在读取数据之后，为了程序能够正常运行，需要对数据进行预处理。</p><ul><li>对图像数据进行归一化操作，因为每个像素点的值是在0-255范围内，进行归一化可以减少运算量，同时避免运算结果溢出；</li><li>对labels进行one-hot编码，这一步骤主要是为了计算交叉熵损失函数时能够正常运行。one-hot编码指的是正确解的标签为1，其余为0，比如3表示为”0010000000“。</li></ul><p>one-hot编码的python实现如下：</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dense_to_one_hot</span><span class="hljs-params">(labels_dense, num_classes)</span>:</span>    <span class="hljs-string">"""    Convert class labels from scalars to one-hot vectors.    num_classes: 总共的类别数    """</span>    num_labels = labels_dense.shape[<span class="hljs-number">0</span>]    <span class="hljs-comment"># 偏移量，arange函数产生0，1，num_labels-1之间的数</span>    index_offset = np.arange(num_labels) * num_classes    labels_one_hot = np.zeros((num_labels, num_classes))    <span class="hljs-comment"># flat返回一个一维迭代器，ravel()函数将多维数组转化为一维数组</span>    labels_one_hot.flat[index_offset + labels_dense.ravel()] = <span class="hljs-number">1</span>    <span class="hljs-keyword">return</span> labels_one_hot</code></pre></div><h1 id="初始化参数"><a href="#初始化参数" class="headerlink" title="初始化参数"></a>初始化参数</h1><p>首先需要初始化参数，b直接全部初始化为0，W使用<code>randn</code>生成随机数，注意b和W不能全部都一样，否则任意一层中的每个神经元输出都一样，最后反向传播也一样，就没有任何意义了。</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment"># x: 784*60000, 784*1000</span><span class="hljs-comment"># # y: 10*60000, 10*1000</span><span class="hljs-comment"># # W1: 128*784</span><span class="hljs-comment"># # b1: 128*1</span><span class="hljs-comment"># # W2: 64*128</span><span class="hljs-comment"># # b2: 64*1</span><span class="hljs-comment"># # W3: 10*64</span><span class="hljs-comment"># # b3: 10*1</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">init_parameters</span><span class="hljs-params">(layers_dim=<span class="hljs-params">(<span class="hljs-number">784</span>, <span class="hljs-number">25</span>, <span class="hljs-number">12</span>, <span class="hljs-number">10</span>)</span>)</span>:</span>    <span class="hljs-string">"""    初始化参数    :return:    """</span>    m = len(layers_dim)    parameters = &#123;&#125;    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(m - <span class="hljs-number">1</span>):        <span class="hljs-comment"># randn生成的随机数符合标准高斯分布，期望为0，方差为1</span>        parameters[<span class="hljs-string">'W'</span> + str(i + <span class="hljs-number">1</span>)] = np.random.randn(layers_dim[i + <span class="hljs-number">1</span>], layers_dim[i]) * <span class="hljs-number">0.001</span>        parameters[<span class="hljs-string">'b'</span> + str(i + <span class="hljs-number">1</span>)] = np.zeros((layers_dim[i + <span class="hljs-number">1</span>], <span class="hljs-number">1</span>))    <span class="hljs-keyword">return</span> parameters</code></pre></div><h1 id="前向传播"><a href="#前向传播" class="headerlink" title="前向传播"></a>前向传播</h1><p>前向传播的基本步骤是先使用一个线性函数，然后使用激励函数将结果非线性化。可以如下表示：</p><div class="hljs"><pre><code class="hljs python">y = Wx + ba = activation(y) <span class="hljs-comment"># 使用时用具体的激励函数替换</span></code></pre></div><p>实验中主要使用了<code>tanh</code>和<code>softmax</code>这两个激励函数。<code>tanh</code>函数公式及python实现如下：</p><script type="math/tex; mode=display">y = \frac{e^x - e^{-x}}{e^x + e^{-x}} \tag{1}</script><div class="hljs"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tanh</span><span class="hljs-params">(x)</span>:</span>    <span class="hljs-keyword">return</span> (np.exp(x) - np.exp(-x)) / (np.exp(x) + np.exp(-x))</code></pre></div><p><code>softmax</code>函数公式及python实现如下, </p><script type="math/tex; mode=display">\operatorname{Softmax}\left(x_{i}\right)=\frac{e^{x_i}}{\sum_{j} e^{x_{j}}} \tag{2}</script><p>需要注意的是，在python实现<code>softmax</code>时，为了避免计算溢出，可以减去一个最大值之后，再进行指数运算。</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">softmax</span><span class="hljs-params">(z)</span>:</span>    <span class="hljs-comment"># 实现softmax分类器输出转化</span>    c = np.max(z)    z_exp = np.exp(z - c) <span class="hljs-comment"># 避免指数运算产生溢出</span>    z_sum_column = z_exp.sum(axis=<span class="hljs-number">0</span>).T    <span class="hljs-keyword">return</span> z_exp / z_sum_column</code></pre></div><h1 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h1><p>反向传播过程主要根据链式规则求解各个参数的关于损失函数的梯度，以便对参数进行优化，从而使损失值减小。实验中损失函数使用的是交叉熵损失函数，可以表示为：</p><script type="math/tex; mode=display">L = -{\sum_{i} {y_i \log{a_i}}} \tag{3}</script><p>其中 $y_i$ 表示实际值，$a_i$ 表示预测值, 而 $a_i$ 是经过softmax函数得到的结果，即 $a_i$ 可以表示为：</p><script type="math/tex; mode=display">a_i = \frac{e^{z_i}}{\sum_{j} e^{z_{j}}} \tag{4}</script><p>则 $a_j$ 对 $z_i$ 求偏导数，可得：</p><script type="math/tex; mode=display">\frac{\partial a_{j}}{\partial z_{i}}=\left\{\begin{array}{ll}a_{i}\left(1-a_{i}\right), & i=j \\-a_{i} a_{j} & i \neq j\end{array}\right. \tag{5}</script><p>使用上式，L 对 $z_i$ 求偏导数得： </p><script type="math/tex; mode=display">\begin{array}{l}\quad \frac{\partial L}{\partial z_{i}}=\frac{\partial L}{\partial a_j} \frac{\partial a_j}{\partial z_i}=\sum_{j}-\frac{y i}{a_{j}} \frac{\partial a_{j}}{\partial z_{i}} \\=\frac{-y_{i}}{a_{i}} a_{i}\left(1-a_{i}\right)+\sum_{j}^{j \neq i}-\frac{y_{i}}{a_{j}}\left(-a_{i} a_{j}\right) \\=-y_{i}\left(1 - a_{i}\right)+\sum_{j=1}^{j \neq i} a_{i} y_{j} \\=a_{i} y_{i}-y_{i}+a_{i} \sum_{i \neq j} y_{j} \\=a_{i} \sum_{j} y_{j}-y_{i}=a_{i}-y_{i}\end{array}</script><p>记上式为$dZ$ , 然后计算 $\frac{\partial L}{\partial W}$，其中X为上一层传进来的数据。:</p><script type="math/tex; mode=display">\frac{\partial L}{\partial W} = \frac{\partial L}{\partial Z} \frac{\partial Z}{\partial W} \\= dZX</script><p>实验中还是用了<code>tanh</code>函数，其导数为：</p><script type="math/tex; mode=display">f(x)^{\prime}=1-(\tanh (x))^{2} \tag{6}</script><p>反向传播各个过程的偏导数都求出来之后，就可以编码实现了，具体代码如下：</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backward_propagation</span><span class="hljs-params">(x, y, cache, parameters)</span>:</span>    <span class="hljs-string">"""    x: 网络中的输入数据    y: 网络的输出数据    cache：缓存各阶段计算的结果    """</span>    W2 = parameters[<span class="hljs-string">'W2'</span>]    W3 = parameters[<span class="hljs-string">'W3'</span>]    m = y.shape[<span class="hljs-number">0</span>]    (Z1, A1, Z2, A2, Z3, A3) = cache    dz3 = A3 - y    dW3 = np.dot(dz3, A2.T) / m    db3 = np.mean(dz3, axis=<span class="hljs-number">1</span>, keepdims=<span class="hljs-keyword">True</span>)    da2 = np.dot(W3.T, dz3)    dz2 = np.multiply(da2, <span class="hljs-number">1</span> - np.multiply(A2, A2))    dW2 = np.dot(dz2, A1.T) / m    db2 = np.mean(dz2, axis=<span class="hljs-number">1</span>, keepdims=<span class="hljs-keyword">True</span>)    da1 = np.dot(W2.T, dz2)    dz1 = np.multiply(da1, <span class="hljs-number">1</span> - np.multiply(A1, A1))    dW1 = np.dot(dz1, x.T) / m    db1 = np.mean(dz1, axis=<span class="hljs-number">1</span>, keepdims=<span class="hljs-keyword">True</span>)    gradients = &#123;<span class="hljs-string">"dz3"</span>: dz3, <span class="hljs-string">"dW3"</span>: dW3, <span class="hljs-string">"db3"</span>: db3,                 <span class="hljs-string">"da2"</span>: da2, <span class="hljs-string">"dz2"</span>: dz2, <span class="hljs-string">"dW2"</span>: dW2, <span class="hljs-string">"db2"</span>: db2,                 <span class="hljs-string">"da1"</span>: da1, <span class="hljs-string">"dz1"</span>: dz1, <span class="hljs-string">"dW1"</span>: dW1, <span class="hljs-string">"db1"</span>: db1&#125;    <span class="hljs-keyword">return</span> gradients</code></pre></div><h1 id="损失函数和优化器"><a href="#损失函数和优化器" class="headerlink" title="损失函数和优化器"></a>损失函数和优化器</h1><p>损失函数使用的是交叉熵损失函数，交叉熵函数的公式见公式(3), 具体实现如下：</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cross_entropy_loss</span><span class="hljs-params">(a, y)</span>:</span>    <span class="hljs-string">"""    交叉熵损失函数    :param a: 预测值    :param y: 实际值    :return:    """</span>    m = a.shape[<span class="hljs-number">1</span>]    <span class="hljs-comment"># 对数操作加1e-7防止出现0</span>    loss = -np.multiply(np.log(a + <span class="hljs-number">1e-7</span>), y).sum(axis=<span class="hljs-number">0</span>)    cost = loss.sum() / m    <span class="hljs-keyword">return</span> cost</code></pre></div><p>使用上述的实现需要注意两点：对实际的label值需要使用<code>one-hot</code>编码；实现中使用了对数运算，为了防止出现0，需要加上一个偏置值。</p><p>梯度下降法根据计算得到的梯度更新参数，从而达到减小损失值的效果，可以表示成如下形式为：</p><script type="math/tex; mode=display">x_{n}^{(i+1)}=x_{n}^{(i)}-\eta \cdot \frac{\partial f}{\partial x_{n}}\left(\mathbf{x}^{(i)}\right)</script><p>其中$\eta$ 指的就是学习率，python实现如下：</p><div class="hljs"><pre><code class="hljs python">ef gradient_descent(parameters, grads, learning_rate):    <span class="hljs-string">"""    使用梯度下降法更新参数    :param parameters:    :param grads:    :param learning_rate:    :return:    """</span>    length = len(parameters) // <span class="hljs-number">2</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(length):        parameters[<span class="hljs-string">"W"</span> + str(i + <span class="hljs-number">1</span>)] = parameters[<span class="hljs-string">"W"</span> + str(i + <span class="hljs-number">1</span>)] - learning_rate * grads[<span class="hljs-string">"dW"</span> + str(i + <span class="hljs-number">1</span>)]        parameters[<span class="hljs-string">"b"</span> + str(i + <span class="hljs-number">1</span>)] = parameters[<span class="hljs-string">"b"</span> + str(i + <span class="hljs-number">1</span>)] - learning_rate * grads[<span class="hljs-string">"db"</span> + str(i + <span class="hljs-number">1</span>)]    <span class="hljs-keyword">return</span> parameters</code></pre></div><h1 id="训练及预测"><a href="#训练及预测" class="headerlink" title="训练及预测"></a>训练及预测</h1><p>训练过程：初始化参数—&gt;前向传播—&gt;反向传播—&gt;参数优化。</p><p>训练过程的参数设置如下：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attr">epochs</span> = <span class="hljs-number">100</span><span class="hljs-attr">BATCH_SIZE</span> = <span class="hljs-number">100</span><span class="hljs-attr">learning_rate</span> = <span class="hljs-number">0.005</span></code></pre></div><p>实验时，把训练和预测两部分放到了一起运行，执行过程如下，其中正确率达到了97.83%</p><p><img src="http://image.ningxin.site/20200615153942.png" srcset="/img/loading.gif" alt=""></p><p>loss值下降过程如下： </p><p><img src="http://image.ningxin.site/20200615161053.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚拟机搭建Hadoop过程记录</title>
    <link href="/2020/06/07/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%90%AD%E5%BB%BAHadoop%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/06/07/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%90%AD%E5%BB%BAHadoop%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-搭建Hadoop分布式集群环境"><a href="#1-搭建Hadoop分布式集群环境" class="headerlink" title="1. 搭建Hadoop分布式集群环境"></a>1. 搭建Hadoop分布式集群环境</h1><h2 id="1-1-安装Linux虚拟机"><a href="#1-1-安装Linux虚拟机" class="headerlink" title="1.1 安装Linux虚拟机"></a>1.1 安装Linux虚拟机</h2><p>首先下载并安装VirtualBox 6.1.8，然后准备安装Linux虚拟机，需要提前下载好镜像文件，我下载的是<code>ubuntu-16.04.6-server-amd64.iso</code>。然后新建一个虚拟机，分配1G内存，10G虚拟空间。在新建虚拟机之后，需要注意以下设置：</p><ul><li>设置启动顺序：如下图所示，将光驱启动调到最前面。</li></ul><a id="more"></a><p><img src="http://image.ningxin.site/20200603230721.png" srcset="/img/loading.gif" alt=""></p><ul><li>如下选择镜像文件的存放位置：</li></ul><p><img src="http://image.ningxin.site/20200603230506.png" srcset="/img/loading.gif" alt=""></p><p>完成上述操作后，点击运行进行虚拟机的安装。重复操作，安装如下四台虚拟机，其中ubuntu作为master，slave1、slave2、slave3作为slave。</p><p><img src="http://image.ningxin.site/20200603231706.png" srcset="/img/loading.gif" alt=""></p><h2 id="1-2-配置Hadoop环境"><a href="#1-2-配置Hadoop环境" class="headerlink" title="1.2 配置Hadoop环境"></a>1.2 配置Hadoop环境</h2><h3 id="1-2-3-前置条件"><a href="#1-2-3-前置条件" class="headerlink" title="1.2.3 前置条件"></a>1.2.3 前置条件</h3><h4 id="1-2-3-1-编辑hostname文件"><a href="#1-2-3-1-编辑hostname文件" class="headerlink" title="1.2.3.1 编辑hostname文件"></a>1.2.3.1 编辑hostname文件</h4><p>使用<code>hostnamectl set-hostname</code>命令设置hostname分别为master、slave1、slave2、slave3</p><p><img src="http://image.ningxin.site/20200603232421.png" srcset="/img/loading.gif" alt=""></p><h4 id="1-2-3-2-编辑hosts文件"><a href="#1-2-3-2-编辑hosts文件" class="headerlink" title="1.2.3.2 编辑hosts文件"></a>1.2.3.2 编辑hosts文件</h4><p>hosts文件用来记录IP和hostname之间的对应关系。使用<code>ifconfig</code>命令来查看IP地址，最后发现4台虚拟机的IP地址是一样的，需要修改网线连接方式，如下选择<code>桥接网卡</code>即可：<br><img src="http://image.ningxin.site/20200603232752.png" srcset="/img/loading.gif" alt=""></p><p>然后修改<code>/etc/hosts</code>文件，如下所示：</p><p><img src="http://image.ningxin.site/20200603232949.png" srcset="/img/loading.gif" alt=""></p><h4 id="1-2-3-3-配置ssh免密登录"><a href="#1-2-3-3-配置ssh免密登录" class="headerlink" title="1.2.3.3 配置ssh免密登录"></a>1.2.3.3 配置ssh免密登录</h4><p>在master上使用<code>ssh-keygen -t rsa</code>命令生成密钥（保存在<code>~/.ssh</code>目录下），然后将公钥上传到slave的<code>~/.ssh/authorized_keys</code>中即可。</p><h2 id="1-2-安装并配置jdk"><a href="#1-2-安装并配置jdk" class="headerlink" title="1.2 安装并配置jdk"></a>1.2 安装并配置jdk</h2><p>首先在Windows上下载<code>jdk-8u251-linux-x64.tar.gz</code>，然后使用pscp工具上传到Linux虚拟机上。</p><p><img src="http://image.ningxin.site/20200602154744.png" srcset="/img/loading.gif" alt=""></p><p>将jdk解压在<code>/usr/java/</code>目录下，然后配置java环境变量，在<code>/etc/profile</code>文件中添加如下内容，然后运行<code>source /etc/profile</code>命令使环境变量生效：</p><div class="hljs"><pre><code class="hljs undefined">export JAVA_HOME=<span class="hljs-regexp">/usr/java</span><span class="hljs-regexp">/jdk1.8.0_251export CLASSPATH=.:$CLASSPATH:$JAVA_HOME/</span><span class="hljs-symbol">LIB:</span>$JAVA_HOME/jre/<span class="hljs-class"><span class="hljs-keyword">lib</span></span>export PATH=$<span class="hljs-symbol">PATH:</span>$JAVA_HOME/<span class="hljs-symbol">bin:</span>$JAVA_HOME/jre/bin</code></pre></div><h2 id="1-3-安装并配置Hadoop"><a href="#1-3-安装并配置Hadoop" class="headerlink" title="1.3 安装并配置Hadoop"></a>1.3 安装并配置Hadoop</h2><h3 id="1-3-1-配置环境变量"><a href="#1-3-1-配置环境变量" class="headerlink" title="1.3.1 配置环境变量"></a>1.3.1 配置环境变量</h3><p>先从Windows上下载Hadoop2.10.0并上传到Linux虚拟机上，解压到<code>/usr/hadoop/</code>目录下，然后添加如下环境变量：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">HADOOP_HOME</span>=/usr/hadoop/hadoop-2.10.0<span class="hljs-builtin-name">export</span> <span class="hljs-attribute">PATH</span>=<span class="hljs-variable">$PATH</span>:$HADOOP_HOME/bin:$HADOOP_HOME/sbin</code></pre></div><h3 id="1-3-2-配置相关配置文件"><a href="#1-3-2-配置相关配置文件" class="headerlink" title="1.3.2 配置相关配置文件"></a>1.3.2 配置相关配置文件</h3><p>以下提到的配置文件都位于<code>etc/hadoop/</code>目录下。</p><p><img src="http://image.ningxin.site/20200604105619.png" srcset="/img/loading.gif" alt=""></p><p>注意：只需要修改master中的Hadoop配置文件，然后将配置好的Hadoop上传到slave中去即可，避免重复配置的麻烦。</p><h4 id="1-3-2-1-hadoop-env-sh-和-yarn-env-sh"><a href="#1-3-2-1-hadoop-env-sh-和-yarn-env-sh" class="headerlink" title="1.3.2.1 hadoop-env.sh 和 yarn-env.sh"></a>1.3.2.1 hadoop-env.sh 和 yarn-env.sh</h4><p>两个文件都是修改<code>JAVA_HOME</code>的值，需要使用实际的路径，而不是环境变量。<br><img src="http://image.ningxin.site/20200602161801.png" srcset="/img/loading.gif" alt=""></p><h4 id="1-3-2-2-core-site-xml"><a href="#1-3-2-2-core-site-xml" class="headerlink" title="1.3.2.2 core-site.xml"></a>1.3.2.2 core-site.xml</h4><p>配置监听端口和缓存目录，缓存目录不存在则需要创建。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-params">&lt;configuration&gt;</span><span class="hljs-meta"># HDFS Web UI 监听端口配置</span><span class="hljs-params">&lt;property&gt;</span><span class="hljs-params">&lt;name&gt;</span>fs.defaultFS<span class="hljs-params">&lt;/name&gt;</span><span class="hljs-params">&lt;value&gt;</span>hdfs:<span class="hljs-comment">//master:8020&lt;/value&gt;</span><span class="hljs-params">&lt;/property&gt;</span><span class="hljs-meta"># hadoop 缓存目录，更改为自己的目录（从根目录开始，不存在需创建）</span><span class="hljs-params">&lt;property&gt;</span><span class="hljs-params">&lt;name&gt;</span>hadoop.tmp.dir<span class="hljs-params">&lt;/name&gt;</span><span class="hljs-params">&lt;value&gt;</span>file:<span class="hljs-meta-keyword">/root/</span>software/hadooptmp<span class="hljs-params">&lt;/value&gt;</span><span class="hljs-params">&lt;/property&gt;</span><span class="hljs-params">&lt;/configuration&gt;</span></code></pre></div><h4 id="1-3-2-3-hdfs-site-xml"><a href="#1-3-2-3-hdfs-site-xml" class="headerlink" title="1.3.2.3 hdfs-site.xml"></a>1.3.2.3 hdfs-site.xml</h4><p>需要创建HDFS存储目录，namenode用来存储namenode文件，data存储datanode数据，tmp存储临时文件。</p><div class="hljs"><pre><code class="hljs undefined">usr<span class="hljs-regexp">/hadoop/</span>hadoop-<span class="hljs-number">2.10</span>.<span class="hljs-number">0</span><span class="hljs-regexp">/hdfs/</span>namenodeusr<span class="hljs-regexp">/hadoop/</span>hadoop-<span class="hljs-number">2.10</span>.<span class="hljs-number">0</span><span class="hljs-regexp">/hdfs/</span>datausr<span class="hljs-regexp">/hadoop/</span>hadoop-<span class="hljs-number">2.10</span>.<span class="hljs-number">0</span><span class="hljs-regexp">/hdfs/</span>tmp</code></pre></div><p><img src="http://image.ningxin.site/20200602164047.png" srcset="/img/loading.gif" alt=""></p><h4 id="1-3-2-4-mapred-site-xml"><a href="#1-3-2-4-mapred-site-xml" class="headerlink" title="1.3.2.4 mapred-site.xml"></a>1.3.2.4 mapred-site.xml</h4><p><code>mapred-site.xml</code>文件需要从<code>mapred-site.xml.template</code>使用cp命令生成：<br><code>cp mapred-site.xml.template mapred-site.xml</code>。然后设置MapReduce运行于yarn上：</p><p><img src="http://image.ningxin.site/20200602164356.png" srcset="/img/loading.gif" alt=""></p><h4 id="1-3-2-5-yarn-site-xml"><a href="#1-3-2-5-yarn-site-xml" class="headerlink" title="1.3.2.5 yarn-site.xml"></a>1.3.2.5 yarn-site.xml</h4><p><img src="http://image.ningxin.site/20200602164735.png" srcset="/img/loading.gif" alt=""></p><p>上面<code>yarn-site.xml</code>文件中将<code>hostname</code>错打成<code>hostnane</code>，最后导致Hadoop运行wordcount时，不能结束，修改后如下：</p><p><img src="http://image.ningxin.site/20200603095221.png" srcset="/img/loading.gif" alt=""></p><h4 id="1-3-2-6-slaves"><a href="#1-3-2-6-slaves" class="headerlink" title="1.3.2.6 slaves"></a>1.3.2.6 slaves</h4><p>在slaves文件中添加如下内容来设置slave：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attribute">slave1</span>slave2slave3</code></pre></div><h3 id="1-3-3-启动Hadoop"><a href="#1-3-3-启动Hadoop" class="headerlink" title="1.3.3 启动Hadoop"></a>1.3.3 启动Hadoop</h3><p>第一次启动需要使用<code>hdfs namenode -format</code>格式化文件系统，出现“Cannot create directory /usr/hadoop/hadoop-2.10.0/hdfs/namenode/current”错误，显示无法创建current文件。无法创建目录的原因是因为<code>hadoop-2.10.0</code>的文件拥有者是<code>root</code>，直接使用<code>sudo hdfs namenode -format</code>会出现找不到命令的错误，两种解决方法：1. 使用<code>sudo su</code>切换到管理员身份；2. 修改<code>hadoop-2.10.0</code>的文件拥有者为普通用户。</p><ul><li>启动: 使用<code>start-dfs.sh</code>启动分布式文件系统。</li></ul><p><img src="http://image.ningxin.site/20200602213020.png" srcset="/img/loading.gif" alt=""></p><ul><li>jps: 使用jps命令验证HDFS是否启动成功</li></ul><p><img src="http://image.ningxin.site/20200602213149.png" srcset="/img/loading.gif" alt=""></p><ul><li>启动yarn: 使用<code>start-yarn.sh</code>启动yarn</li></ul><p><img src="http://image.ningxin.site/20200602214232.png" srcset="/img/loading.gif" alt=""></p><ul><li>浏览器: 在浏览器中输入<code>http:master:50070</code>查看UI界面</li></ul><p><img src="http://image.ningxin.site/20200602214338.png" srcset="/img/loading.gif" alt=""></p><h1 id="2-HDFS文件上传"><a href="#2-HDFS文件上传" class="headerlink" title="2. HDFS文件上传"></a>2. HDFS文件上传</h1><p>创建<code>input.txt</code>文件并输入以下内容：</p><p><img src="http://image.ningxin.site/20200604001324.png" srcset="/img/loading.gif" alt=""></p><p>使用<code>hdfs dfs -put</code>命令将文件上传到hdfs中，然后使用<code>hdfs dfs -cat</code>命令查看文件中的具体内容。</p><p><img src="http://image.ningxin.site/20200604001901.png" srcset="/img/loading.gif" alt=""></p><h1 id="3-运行wordcount程序"><a href="#3-运行wordcount程序" class="headerlink" title="3. 运行wordcount程序"></a>3. 运行wordcount程序</h1><p>wordcount程序在<code>share/hadoop/hadoop-mapreduce-examples-2.10.0.jar</code>包中, 运行该程序之前需要提前创建输入文件,输出文件不需要创建， 输入输出文件如下：</p><div class="hljs"><pre><code class="hljs undefined">/wordcount/input/<span class="hljs-selector-tag">input</span><span class="hljs-selector-class">.txt</span>/wordcount/output（不要创建）</code></pre></div><p>其中<code>input.txt</code>文件中的内容如下：</p><p><img src="http://image.ningxin.site/20200603100517.png" srcset="/img/loading.gif" alt=""></p><p>然后使用命令<code>hadoop jar hadoop-mapreduce-examples-2.10.0.jar wordcount /wordcount/input/input.txt /wordcount/output</code>运行wordcount程序，结果如下：<br><img src="http://image.ningxin.site/20200603100155.png" srcset="/img/loading.gif" alt=""></p><p>使用命令<code>hdfs dfs -cat /wordcount/output/part-r-00000</code>查看输出结果：<br><img src="http://image.ningxin.site/20200603100430.png" srcset="/img/loading.gif" alt=""></p><h1 id="4-编写wordcount程序"><a href="#4-编写wordcount程序" class="headerlink" title="4. 编写wordcount程序"></a>4. 编写wordcount程序</h1><p>wordcount程序见附件<code>WordCount.java</code>。</p><p>master中创建如下目录, 其中src存放java文件，classes存放class文件：</p><div class="hljs"><pre><code class="hljs undefined">~<span class="hljs-regexp">/wordcount/</span>src~<span class="hljs-regexp">/wordcount/</span>classes</code></pre></div><h2 id="4-1-编译"><a href="#4-1-编译" class="headerlink" title="4.1 编译"></a>4.1 编译</h2><p>编译时需要引入的包如下：</p><div class="hljs"><pre><code class="hljs undefined">share/hadoop/common/hadoop-common-<span class="hljs-number">2.10</span>.<span class="hljs-number">0</span>.jarshare/hadoop/mapreduce/hadoop-mapreduce-client-core-<span class="hljs-number">2.10</span>.<span class="hljs-number">0</span>.jarshare/hadoop/common/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">commons</span>-<span class="hljs-title">cli</span>.1.2.<span class="hljs-title">jar</span></span></code></pre></div><p>使用javac命令进行编译，并用<code>-classpath</code>指定引入的包，<code>-d</code>指定输出目录：</p><p><img src="http://image.ningxin.site/20200603213806.png" srcset="/img/loading.gif" alt=""></p><h2 id="4-2-打包"><a href="#4-2-打包" class="headerlink" title="4.2 打包"></a>4.2 打包</h2><p>使用命令<code>jar -cvf wordcount.jar classes/</code>进行打包：</p><p><img src="http://image.ningxin.site/20200603213924.png" srcset="/img/loading.gif" alt=""></p><h2 id="4-3-运行"><a href="#4-3-运行" class="headerlink" title="4.3 运行"></a>4.3 运行</h2><p>使用如下命令运行wordcount.jar</p><p><code>hadoop jar wordcount.jar WordCount /wordcount/input/input.txt /output</code></p><p>然后出现<code>Class WordCount$Reduce not found</code>的错误，最后使用如下打包命令，解决问题：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-selector-tag">jar</span> <span class="hljs-selector-tag">cf</span> <span class="hljs-selector-tag">wordcount</span><span class="hljs-selector-class">.jar</span> <span class="hljs-selector-tag">WordCount</span>*<span class="hljs-selector-class">.class</span></code></pre></div><p>运行界面如下：<br><img src="http://image.ningxin.site/20200603221301.png" srcset="/img/loading.gif" alt=""></p><p>运行后的输出结果如下：<br><img src="http://image.ningxin.site/20200603221509.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hadoop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3D-UNet笔记</title>
    <link href="/2020/06/03/3D-UNet%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/06/03/3D-UNet%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://arxiv.org/pdf/1606.06650.pdf" target="_blank" rel="noopener">论文地址</a></p><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><p>医学图像通常是由多个2D切片构成一整张图，对这样的数据进行标注比较困难,只能一张一张地标注2D图像，并将2D图像送进模型进行训练，但相邻的切片几乎一样，因此这样的做法效率很低。<br>论文的作者提出了3D U-Net模型，该模型主要有两种应用：</p><ul><li>semi-automated setup:  可以对只进行了稀疏标注的数据集进行训练；</li><li>fully-automated setup:  假设稀疏标注集存在，对该数据集进行训练。</li></ul><a id="more"></a><h1 id="2-网络结构"><a href="#2-网络结构" class="headerlink" title="2. 网络结构"></a>2. 网络结构</h1><p><img src="http://image.ningxin.site/20200603160416.png" srcset="/img/loading.gif" alt="网络结构"><br>该模型分为<code>analysis path</code> 和 <code>synthesis path</code>两个部分，主要结构和<code>U-Net</code>一样。</p><p><code>analysis path</code> 主要包括以下操作：该部分有4层，每一层都包含两个<code>3 x 3 x 3</code>的卷积，每次卷积之后进行<code>batch normalizetion</code>(BN) 操作和<code>ReLu</code>操作，然后进行strides为2的<code>2 x 2 x 2</code>的最大池化操作。</p><p><code>synthesis path</code> 主要包括以下操作：该部分有3层，每一层首先使用一个strides为2、卷积核为<code>2 x 2 x 2</code>的反卷积操作，然后与<code>analysis path</code>中对应的<code>fature map</code>进行cat操作，再然后是两个<code>3 x 3 x 3</code>的卷积操作，每次卷积之后进行<code>batch normalizetion</code>(BN) 操作和<code>ReLu</code>操作，然后进行strides为2的<code>2 x 2 x 2</code>的最大池化操作。</p><p>在最后一层输出时使用<code>1 x 1 x 1</code>的卷积来减少通道数。</p><p>论文中提到的一个亮点就是，3D U-Net使用了<code>weighted softmax loss function</code>将未标记的像素点设置为0以至于可以让网络可以更多地仅仅学习标注到的像素点，从而达到普适性地特点。</p><h1 id="3-训练"><a href="#3-训练" class="headerlink" title="3. 训练"></a>3. 训练</h1><p>3D U-Net采用了数据增强（data augmentation），主要是rotation、scaling和将图像设置为gray，于此同时在训练数据上和真实标注的数据上运用平滑的密集变形场(smooth dense deformation field)。</p>]]></content>
    
    
    <categories>
      
      <category>论文阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习</tag>
      
      <tag>论文阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>V-Net笔记</title>
    <link href="/2020/05/24/V-Net%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/05/24/V-Net%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><p>V-Net用于3D图像分割（基于3D卷积），引入了新的目标函数（<code>Dice coefficient</code>）,采用<code>random non-linear transformation</code>和<code>histogram matching</code>的数据扩充方法。</p><h1 id="2-网络结构"><a href="#2-网络结构" class="headerlink" title="2. 网络结构"></a>2. 网络结构</h1><p><img src="https://gitee.com/huster_ning/image/raw/master/image/Snipaste_2020-05-27_21-15-06.jpg" srcset="/img/loading.gif" alt="Snipaste_2020-05-27_21-15-06"></p><a id="more"></a><p>网络的左侧部分由压缩路径组成，而右侧部分解压缩直到达到其原始大小。</p><h2 id="2-1-压缩路径"><a href="#2-1-压缩路径" class="headerlink" title="2.1 压缩路径"></a>2.1 压缩路径</h2><p>压缩路径中每个阶段中执行几次<code>5 x 5 x 5</code>大小的卷积操作，卷积之后使用<code>PReLU</code>函数进行非线性化操作，然后执行<code>element-wise sum</code>操作，再执行步幅为2的<code>2 x 2 x 2</code>的卷积（该步骤是使用卷积代替池化操作），将分辨率变为原来的一半。每个阶段执行完后，通道数变为原来的两倍。</p><ul><li>卷积代替池化：能够有更小的内存占用，网络性能更好</li><li>element-wise sum操作：如下图所示，首先16个x执行cat操作得到x16, 得到的x16的维度与out一致，<code>element-wise sum</code>操作就是将x16和out的对应像素点执行相加操作。</li></ul><div class="hljs"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span><span class="hljs-params">(self, x)</span>:</span>    <span class="hljs-comment"># do we want a PRELU here as well?</span>    out = self.bn1(self.conv1(x))    <span class="hljs-comment"># split input in to 16 channels</span>    <span class="hljs-comment"># 增加通道数与out一致</span>    x16 = torch.cat((x, x, x, x, x, x, x, x,                     x, x, x, x, x, x, x, x), <span class="hljs-number">0</span>)    <span class="hljs-comment"># 执行element-wise sum操作之后在执行relu1</span>    out = self.relu1(torch.add(out, x16))    <span class="hljs-keyword">return</span> out</code></pre></div><h2 id="2-2-解压缩路径"><a href="#2-2-解压缩路径" class="headerlink" title="2.2 解压缩路径"></a>2.2 解压缩路径</h2><p>在解压缩路径中，与<code>U-Net</code>类似，将网络左侧部分的早期阶段提取的特征转发到右侧部分，即网络结构图中的<code>Fine-grained features forwarding</code>操作。通过这种方式，可以收集在压缩路径中丢失的细粒度细节，并且可以提高最终轮廓预测的质量。每个阶段采用反卷积操作，将分辨率提高到原来的两倍，并且通道数变为原来的一半。最后使用一个<code>1 x 1 x 1</code>的卷积得到与输入大小相同的结果，并使用softmax函数得到概率分割图。</p><ul><li><code>Fine-grained features fowarding</code>: 左侧特征图与右侧对应特征图执行拼接操作。 </li></ul><h1 id="3-Dice-loss-layer"><a href="#3-Dice-loss-layer" class="headerlink" title="3. Dice loss layer"></a>3. Dice loss layer</h1><h2 id="3-1-Dice系数"><a href="#3-1-Dice系数" class="headerlink" title="3.1 Dice系数"></a>3.1 Dice系数</h2><p>参考博客<a href="https://www.aiuai.cn/aifarm1159.html" target="_blank" rel="noopener">医学图像分割之 Dice Loss</a></p><p>Dice系数，是一种集合相似度度量函数，通常用于计算两个样本的相似度（值范围为[0, 1]）:</p><script type="math/tex; mode=display">s=\frac{2|X \bigcap Y|}{|X|+|Y|}</script><p> $|X \bigcap Y|$ 表示X 和 Y 之间的交集；|X| 和 |Y| 分别表示 X 和 Y 的元素个数. 其中，分子中的系数 2，是因为分母存在重复计算 X 和 Y 之间的共同元素的原因.</p><p>在真正计算时可以将 |X⋂Y| 近似为预测图与 GT 分割图之间的点乘，并将点乘的元素结果相加求和：</p><script type="math/tex; mode=display">|X \bigcap Y|=\left[\begin{array}{cccc}0.01 & 0.03 & 0.02 & 0.02 \\0.05 & 0.12 & 0.09 & 0.07 \\0.89 & 0.85 & 0.88 & 0.91 \\0.99 & 0.97 & 0.95 & 0.97\end{array}\right] *\left[\begin{array}{cccc}0 & 0 & 0 & 0 \\0 & 0 & 0 & 0 \\1 & 1 & 1 & 1 \\1 & 1 & 1 & 1\end{array}\right]</script><h2 id="3-2-Dice系数在医学图像分割中的应用"><a href="#3-2-Dice系数在医学图像分割中的应用" class="headerlink" title="3.2 Dice系数在医学图像分割中的应用"></a>3.2 Dice系数在医学图像分割中的应用</h2><p>在以前的损失函数中，前景区域在学习期间比背景区域更重要。在V-Net中提出了一个基于Dice系数的新的目标函数，目标是求最大值。</p><script type="math/tex; mode=display">D=\frac{2 \sum_{i}^{N} p_{i} g_{i}}{\sum_{i}^{N} p_{i}^{2}+\sum_{i}^{N} g_{i}^{2}}</script><p>其中pi为预测结果，gi为实际结果。Dice系数的梯度为：</p><script type="math/tex; mode=display">\frac{\partial D}{\partial p_{j}}=2\left[\frac{g_{j}\left(\sum_{i}^{N} p_{i}^{2}+\sum_{i}^{N} g_{i}^{2}\right)-2 p_{j}\left(\sum_{i}^{N} p_{i} g_{i}\right)}{\left(\sum_{i}^{N} p_{i}^{2}+\sum_{i}^{N} g_{i}^{2}\right)^{2}}\right]</script><h2 id="3-3-Dice系数的Pytorch实现"><a href="#3-3-Dice系数的Pytorch实现" class="headerlink" title="3.3 Dice系数的Pytorch实现"></a>3.3 Dice系数的Pytorch实现</h2><div class="hljs"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dice_loss</span><span class="hljs-params">(pred, target)</span>:</span>    <span class="hljs-string">"""This definition generalize to real valued pred and target vector.This should be differentiable.    pred: tensor with first dimension as batch    target: tensor with first dimension as batch    """</span>smooth = <span class="hljs-number">1.</span><span class="hljs-comment"># have to use contiguous since they may from a torch.view op</span>iflat = pred.contiguous().view(<span class="hljs-number">-1</span>)tflat = target.contiguous().view(<span class="hljs-number">-1</span>)intersection = (iflat * tflat).sum()A_sum = torch.sum(iflat * iflat)B_sum = torch.sum(tflat * tflat)<span class="hljs-keyword">return</span> (<span class="hljs-number">2.</span> * intersection + smooth) / (A_sum + B_sum + smooth)</code></pre></div><h1 id="4-训练"><a href="#4-训练" class="headerlink" title="4. 训练"></a>4. 训练</h1><p>训练时主要采用下面的数据增强方法：</p><ul><li>使用<code>2 x 2 x 2</code>的网格控制点和<code>B-spline interpolation</code>(B样条插值)来获得稠密的形变场对图像进行非线性形变；</li><li>使用直方图匹配来获得不同的灰度分布的图像。 </li></ul>]]></content>
    
    
    <categories>
      
      <category>论文阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习</tag>
      
      <tag>论文阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>U-net笔记</title>
    <link href="/2020/05/21/U-net%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/05/21/U-net%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="U-net"><a href="#U-net" class="headerlink" title="U-net"></a>U-net</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>U-net是对FCN的改进，主要应用于医学图像分割。</p><p>U-net的网络结构如下所示：</p><p><img src="https://gitee.com/huster_ning/image/raw/master/image/v2-96f5e828c1e83c930aa4a2bb91e64c10_r.jpg" srcset="/img/loading.gif" alt="preview"></p><a id="more"></a><p>U-net包括<code>Contracting Path</code> 和 <code>Expanding Path</code> 两个部分，所有卷积层的<code>padding = 0</code>. U-net的计算过程如下：</p><ul><li><p><code>Contracting Path</code>部分进行下采样操作：2个<code>3 x 3</code>的卷积层 + 1个 <code>2 x 2 的 max pool</code>，重复四次以上操作；</p></li><li><p><code>Expanding Path</code>部分：2个<code>3 x 3</code>卷积层 + 1个<code>2 x 2</code>反卷积操作，然后与前面对应的层使用 <strong>拼接操作</strong> 进行特征融合，重复四次以上操作；</p></li><li><p>最后经过2个<code>3 x 3</code>卷积， 1个<code>1 x 1</code>卷积(类似于残差网络，用来降维)，然后使用softmax进行输出。</p></li></ul><h3 id="特征融合"><a href="#特征融合" class="headerlink" title="特征融合"></a>特征融合</h3><p>使用concat操作进行特征融合，而不是使用相加操作进行特征融合</p><p><img src="https://gitee.com/huster_ning/image/raw/master/image/image-20200520160912870.png" srcset="/img/loading.gif" alt="image-20200520160912870"></p><h2 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h2><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>U-net使用的是带权损失函数：</p><script type="math/tex; mode=display">E = \sum_{x\in\Omega}{\omega(x)\log(p_{l(x)}(x))}</script><p>其中 $w(x)$ 指的是权重，其实就是相当于交叉熵乘了一个权重，有点不解的是我看的代码中都是直接使用<code>CrossEntropyLoss</code>进行计算loss，如下代码所示：</p><div class="hljs"><pre><code class="hljs python">unet = Unet(in_channel=<span class="hljs-number">1</span>,out_channel=<span class="hljs-number">2</span>)<span class="hljs-comment">#out_channel represents number of segments desired</span>criterion = torch.nn.CrossEntropyLoss()optimizer = torch.optim.SGD(unet.parameters(), lr = <span class="hljs-number">0.01</span>, momentum=<span class="hljs-number">0.99</span>)optimizer.zero_grad()       outputs = unet(inputs)<span class="hljs-comment"># permute such that number of desired segments would be on 4th dimension</span>outputs = outputs.permute(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>)m = outputs.shape[<span class="hljs-number">0</span>]<span class="hljs-comment"># Resizing the outputs and label to caculate pixel wise softmax loss</span>outputs = outputs.resize(m*width_out*height_out, <span class="hljs-number">2</span>)labels = labels.resize(m*width_out*height_out)loss = criterion(outputs, labels)loss.backward()optimizer.step()</code></pre></div><p>U-net的输入是<code>572 x 572</code>, 而输出是<code>388 x 388</code>，两者不一致，不能直接求损失函数，有两种方法：</p><ul><li>对预期输出从中心crop，使其与输出大小一致;</li><li>对输出结果进行padding操作，使其与输入大小一致。</li></ul><h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>使用梯度下降法（SGD）进行优化。</p>]]></content>
    
    
    <categories>
      
      <category>论文阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习</tag>
      
      <tag>论文阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阿里云服务器发送邮件</title>
    <link href="/2019/07/18/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/"/>
    <url>/2019/07/18/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-在邮箱设置中开启SMTP"><a href="#1-在邮箱设置中开启SMTP" class="headerlink" title="1. 在邮箱设置中开启SMTP"></a>1. 在邮箱设置中开启SMTP</h3><p>SMTP:简单文件传输协议</p><h3 id="2-具体过程参考如下博客"><a href="#2-具体过程参考如下博客" class="headerlink" title="2. 具体过程参考如下博客"></a>2. 具体过程参考如下博客</h3><p><a href="https://yq.aliyun.com/articles/644134" target="_blank" rel="noopener">参考链接</a></p><a id="more"></a><h3 id="3-发送邮件"><a href="#3-发送邮件" class="headerlink" title="3. 发送邮件"></a>3. 发送邮件</h3><ul><li>直接输入正文<blockquote><p>echo “邮件正文” | mail -s “邮件主题(subject)” 邮箱地址</p></blockquote></li><li>正文在文件中<blockquote><p>mail -s “邮件主题(subject)” 邮箱地址 &lt; 邮件正文所在文件<br>cat file | mail -s “邮件主题(subject)” 邮箱地址</p></blockquote></li><li>发送附件<blockquote><p>mail -s “邮件主题(subject)” 邮箱地址 -a 附件</p></blockquote></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>阿里云服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客添加评论功能</title>
    <link href="/2019/07/17/%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD/"/>
    <url>/2019/07/17/%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="yilia主题：gitment评论功能"><a href="#yilia主题：gitment评论功能" class="headerlink" title="yilia主题：gitment评论功能"></a>yilia主题：gitment评论功能</h1><p>下面主要讲述如何使用gitment给yilia主题添加评论功能</p><h2 id="1-Register-a-new-OAuth-application"><a href="#1-Register-a-new-OAuth-application" class="headerlink" title="1. Register a new OAuth application"></a>1. Register a new OAuth application</h2><p><a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">注册OAuth</a><br><a id="more"></a></p><p><img src="https://gitee.com/huster_ning/image/raw/master/image/%E6%B3%A8%E5%86%8C.png" srcset="/img/loading.gif" alt="注册"></p><p>注册完成后能够得到<code>Client ID</code>和<code>Client Serect</code></p><h2 id="2-修改配置文件"><a href="#2-修改配置文件" class="headerlink" title="2. 修改配置文件"></a>2. 修改配置文件</h2><p>修改<code>themes/hexo-theme-yilia/_config.yml</code>下的配置文件（注意不是修改根目录下的_config.yml文件）<br>如下图所示<br><img src="https://gitee.com/huster_ning/image/raw/master/image/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png" srcset="/img/loading.gif" alt="配置文件"><br>最后如果不出问题的话<code>hexo g</code> 、<code>hexo d</code>应该就行了</p><h2 id="3-解决一些遇到的bug"><a href="#3-解决一些遇到的bug" class="headerlink" title="3. 解决一些遇到的bug"></a>3. 解决一些遇到的bug</h2><h3 id="bug：github-api-error-redirect-uri-mismatch"><a href="#bug：github-api-error-redirect-uri-mismatch" class="headerlink" title="bug：github-api-error-redirect-uri-mismatch"></a>bug：github-api-error-redirect-uri-mismatch</h3><p><a href="https://stackoverflow.com/questions/34730153/github-api-error-redirect-uri-mismatch" target="_blank" rel="noopener">参考Stack Overflow</a></p><h3 id="bug：object-ProgressEvent"><a href="#bug：object-ProgressEvent" class="headerlink" title="bug：object ProgressEvent"></a>bug：object ProgressEvent</h3><p>由于服务器认证域名过期，修改服务器即可，<br>修改<code>themes/hexo-theme-yilia/layout/_partial/post/gitment.ejs</code>文件<br>将如下代码<br><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"//imsun.github.io/gitment/style/default.css"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"//imsun.github.io/gitment/dist/gitment.browser.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div></p><p>修改成如下：<br><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/default.css"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/gitment.browser.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div></p><p><a href="https://sjq597.github.io/2018/05/18/Hexo-%E4%BD%BF%E7%94%A8Gitment%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD/" target="_blank" rel="noopener">参考</a></p><h1 id="fluid主题：valine评论"><a href="#fluid主题：valine评论" class="headerlink" title="fluid主题：valine评论"></a>fluid主题：valine评论</h1><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p>修改fluid主题目录下的<code>_config.yml</code>文件，如下所示开启评论并选择使用的评论模块为<code>valine</code></p><div class="hljs"><pre><code class="hljs yml"><span class="hljs-attr">comments:</span>  <span class="hljs-comment"># 评论</span><span class="hljs-attr">    enable:</span> <span class="hljs-literal">true</span>  <span class="hljs-comment"># 开启评论</span><span class="hljs-attr">    type:</span> <span class="hljs-string">valine</span></code></pre></div><p>然后修改<code>valine</code>模块中中的配置信息, 主要是修改appid、appkey、serverURLS这三处信息, 需要 <a href="https://leancloud.cn/dashboard/login.html#/signup" target="_blank" rel="noopener">注册LeanCloud</a>才能获取appid、appkey, 具体操作可参考<a href="https://valine.js.org/quickstart.html" target="_blank" rel="noopener">文档</a><br><div class="hljs"><pre><code class="hljs yml"><span class="hljs-comment"># Valine</span><span class="hljs-comment"># 完整文档 https://valine.js.org/configuration.html</span><span class="hljs-comment"># 注意：下列配置项中的 true/false 不要用引号括起来</span><span class="hljs-attr">valine:</span><span class="hljs-attr">  appid:</span> <span class="hljs-string">xxx</span>  <span class="hljs-comment"># 从 LeanCloud 的应用中得到的 appId</span><span class="hljs-attr">  appkey:</span> <span class="hljs-string">xxx</span>  <span class="hljs-comment"># 从 LeanCloud 的应用中得到的 APP Key</span><span class="hljs-attr">  placeholder:</span> <span class="hljs-string">说点什么</span> <span class="hljs-comment"># 评论框占位提示符</span><span class="hljs-attr">  path:</span> <span class="hljs-string">window.location.pathname</span> <span class="hljs-comment"># 当前文章页路径，用于区分不同的文章页，以保证正确读取该文章页下的评论列表</span><span class="hljs-attr">  avatar:</span> <span class="hljs-string">retro</span> <span class="hljs-comment"># Gravatar 头像展示方式</span><span class="hljs-attr">  meta:</span> <span class="hljs-string">['nick',</span> <span class="hljs-string">'mail'</span><span class="hljs-string">,</span> <span class="hljs-string">'link'</span><span class="hljs-string">]</span>  <span class="hljs-comment"># 评论者相关属性</span><span class="hljs-attr">  pageSize:</span> <span class="hljs-number">10</span> <span class="hljs-comment"># 评论列表分页，每页条数</span><span class="hljs-attr">  lang:</span> <span class="hljs-string">zh-CN</span> <span class="hljs-comment"># zh-CN | zh-TW | en | ja</span><span class="hljs-attr">  highlight:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 代码高亮</span><span class="hljs-attr">  recordIP:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 是否记录评论者IP</span><span class="hljs-attr">  serverURLs:</span>  <span class="hljs-string">xxx</span> <span class="hljs-comment"># REST API 服务器地址，国际版不填</span></code></pre></div></p><h2 id="评论邮件提醒功能"><a href="#评论邮件提醒功能" class="headerlink" title="评论邮件提醒功能"></a>评论邮件提醒功能</h2><p>邮件提醒我使用的是<a href="https://github.com/zhaojun1998/Valine-Admin" target="_blank" rel="noopener">Valine-Admin</a>，参考文档进行Git部署即可。但我在部署时出现了如下错误：</p><p><img src="https://gitee.com/huster_ning/image/raw/master//image/20200701132034.png" srcset="/img/loading.gif" alt=""></p><p>主要是因为Node版本太低了的缘故，需要修改项目中<code>package.json</code>文件中的Node版本，可以将项目fork到自己的仓库中，然后进行修改, 将<code>6.x</code>修改成<code>12.x</code>即可。</p><div class="hljs"><pre><code class="hljs json">"engines": &#123;    "node": "12.x"  &#125;</code></pre></div><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>如果fluid主题使用了覆盖配置，一定记得修改配置时是在<code>source/_data</code>目录下修改，不然配置会无效。</p>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>博客搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java复习笔记</title>
    <link href="/2018/10/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2018/10/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、没有“对象”的java"><a href="#一、没有“对象”的java" class="headerlink" title="一、没有“对象”的java"></a>一、没有“对象”的java</h2><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><ul><li>整数的默认类型是 int </li><li>定义 float 类型时必须在数字后面跟上 F 或者 f </li><li>使用 long 类型时必须在数字后面跟上 L</li></ul><h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><a id="more"></a><p><img src="https://gitee.com/huster_ning/image/raw/master/image/%E4%BC%98%E5%85%88%E7%BA%A7.PNG" srcset="/img/loading.gif" alt="优先级"></p><ul><li><p>静态变量与静态方法属于类所有，因此也叫作<code>类变量</code>、<code>类方法</code>（因此也能理解static方法中不能使用<code>this</code>和<code>super</code>关键字）， <strong>静态变量只能在类主体中定义，不能在方法中定义</strong></p></li><li><p>静态变量与实例变量的区别：静态变量在<code>编译时</code>内存就为其分配空间，直到程序停止才释放；实例变量只有在创建了<code>实例对象</code>时，才会分配空间</p></li></ul><h2 id="二、包"><a href="#二、包" class="headerlink" title="二、包"></a>二、包</h2><p><strong>父包中的类不能直接引用子包中定义的类，import引用父包中所有的类不会引用子包中所有的类</strong></p><h3 id="基础包：java-lang"><a href="#基础包：java-lang" class="headerlink" title="基础包：java.lang"></a>基础包：<code>java.lang</code></h3><ul><li><p>java.lang.Object</p><blockquote><ul><li>所有类的祖先</li><li>仅有一个默认构造方法</li><li>主要成员方法：<blockquote><ul><li>equals(Object obj) : 判断是否为同一对象</li><li>toString() : 返回对象的字符串表示，“类名@对象的十六进制哈希码”</li></ul></blockquote></li></ul></blockquote></li><li><p>包装类</p><blockquote><p>1) 包装类覆盖了Object类的toString()方法，打印时返回对应字符串值<br>2) 数值类都有<code>valueOf(Strings)</code>静态方法，用于创建包装类对象<br>3) 数值类都有<code>parseXXX(Strings)</code>静态方法，用于将字符串转为对应的基本数据类型，<code>parseInteger(String, int radix)</code>按指定进制解析为十进制数</p></blockquote></li></ul><h2 id="三、String理解"><a href="#三、String理解" class="headerlink" title="三、String理解"></a>三、String理解</h2><p><strong><code>10.14补充内容：</code></strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/*** 下面代码中使用了StringBuilder类和 String.valueOf()方法* */</span>String s = <span class="hljs-string">"xinger"</span>;s = s + <span class="hljs-number">9</span>;<span class="hljs-comment">//s = "xinger9"</span>s = s + <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">9</span>);<span class="hljs-comment">//自动使用了String.valueOf()方法</span></code></pre></div><blockquote><p>String是final类，不能被继承，字符串本身不可变</p></blockquote><div class="hljs"><pre><code class="hljs java">&#123;String s =<span class="hljs-string">"xinger"</span>;<span class="hljs-comment">//将常量池中“xinger"的地址赋给引用s</span>s = <span class="hljs-string">"xingxin"</span>;<span class="hljs-comment">//创建了新的对象</span>String s1 = <span class="hljs-string">"xin"</span>;String s2 = s1 + <span class="hljs-string">"ger"</span>;<span class="hljs-comment">//调用了StringBuilder类，创建了新</span><span class="hljs-comment">//的对象，s == s2为false</span>&#125;</code></pre></div><p>第二个s生成了新的对象</p><p><strong>字符串常量的“+” 与字符串引用的“+”的区别:</strong><br>前者在编译器完成，所得常量放在常量池中，后者在运行期间完成，在堆中创建了新的对象</p><h3 id="2-字符串比较"><a href="#2-字符串比较" class="headerlink" title="2.字符串比较"></a>2.字符串比较</h3><ul><li>== 比较引用而不是值</li><li>equals(Object o) 比较值</li><li>int compareTo() 从左至右比较值的大小,相等返回0</li></ul><h3 id="3-字符串常量池、堆、栈"><a href="#3-字符串常量池、堆、栈" class="headerlink" title="3.字符串常量池、堆、栈"></a>3.字符串常量池、堆、栈</h3><ul><li>String s = “xinger” : constant pool</li><li>String s = new String(“xinger”) : heap</li><li>对象引用 变量 : stack</li></ul><h3 id="4-常用方法"><a href="#4-常用方法" class="headerlink" title="4.常用方法"></a>4.常用方法</h3><ul><li><code>String[] split(String regex,int limit)</code></li></ul><blockquote><p>用来分割字符串，limit用来限制匹配次数，并且获得的数组长度不能大于limit</p></blockquote><h4 id="5-StringBuilder"><a href="#5-StringBuilder" class="headerlink" title="5.StringBuilder"></a>5.StringBuilder</h4><blockquote><p><code>StringBuilder</code>是可变字符串，能够多次修改并且不产生新的对象，一个String不能直接给其赋初值，比如：<code>StringBuilder s = &quot;xinger&quot;</code>这是错误的</p></blockquote><h2 id="四、面向对象"><a href="#四、面向对象" class="headerlink" title="四、面向对象"></a>四、面向对象</h2><h3 id="修饰符访问权限"><a href="#修饰符访问权限" class="headerlink" title="修饰符访问权限"></a>修饰符访问权限</h3><blockquote><p>修饰符的访问权限是java更是面向对象最最基础的知识点</p></blockquote><ul><li>注意：无修饰符就是默认权限，也叫包访问权限，只能被同一包内类访问，与<code>protected</code>有细微区别</li><li>外部类的定义<code>only public, abstract &amp; final</code></li></ul><p><img src="https://gitee.com/huster_ning/image/raw/master/image/%E4%BF%AE%E9%A5%B0%E7%AC%A6.jpg" srcset="/img/loading.gif" alt="修饰符"></p><ul><li>类是对象的抽象，对象是类的实例</li><li>继承：代码重用、可扩展性</li></ul><h3 id="一、封装：隐藏细节、模块化"><a href="#一、封装：隐藏细节、模块化" class="headerlink" title="一、封装：隐藏细节、模块化"></a>一、封装：隐藏细节、模块化</h3><ul><li>定义：<code>封装</code>是指一种将抽象性函数接口的<code>实现细节部分包装</code>、<code>隐藏</code>起来的方法。<br>封装可以防止一个类的代码和数据被外部类定义的代码随机访问。<br>而要访问该类的代码和数据，必须通过严格的<code>接口</code>控制。</li></ul><blockquote><p>从设计上讲，为了<code>实现模块化</code></p><ol><li>以类为最小单元，减少修改带来的连锁效应； <ol><li>可以对成员变量进行更精确的控制（getter, setter）；</li></ol></li></ol><p>从使用上讲，<code>减少了复杂度</code></p><ol><li>代码使用者无需考虑实现细节就能直接使用一个类； <ol><li>更有效的协作；</li></ol></li></ol></blockquote><ul><li>良好的封装能够减少代码的耦合，抵御变化</li></ul><h3 id="二、继承：是一种“is-a-kind-of”的关系"><a href="#二、继承：是一种“is-a-kind-of”的关系" class="headerlink" title="二、继承：是一种“is a kind of”的关系"></a>二、继承：是一种“is a kind of”的关系</h3><h4 id="1-继承的特点"><a href="#1-继承的特点" class="headerlink" title="1.继承的特点"></a>1.继承的特点</h4><blockquote><ul><li>在设计时，它允许创建分等级层次的类，思路更清晰，减少了冗余代码，<code>易于修改</code>；</li><li>定义新类时，可以以原来的类为基础，借助代码的<code>重用</code>，使系统变得<code>容易扩展</code>，提 高了开发效率。</li><li>继承帮助我们统一了函数的调用接口，在增加新类后减少对已有系统的修改。</li></ul></blockquote><h4 id="2-继承的实现"><a href="#2-继承的实现" class="headerlink" title="2.继承的实现"></a>2.继承的实现</h4><blockquote><ul><li>创建子类对象实例时，首先调用子类的构造方法，再由子类的构造方法<code>默认</code>地调用父类的<code>无参数</code>的构造方法(隐式调用)， 生成父类的对象。接下来完成调用子类的构造方法，生成子类的对象。</li><li><code>注意</code>：如果父类没有<code>无参数</code>构造函数，则必须用<code>super()</code>显示调用父类构造函数，并且必须放在第一行(<code>super</code>关键字可以调用父类方法)</li><li>向上转型：父类对象是子类对象的上转型对象，不能操作子类新增的方法与属性，但能操作子类重写的方法（这也是与直接使用父类的区别）</li></ul></blockquote><h3 id="三、抽象类"><a href="#三、抽象类" class="headerlink" title="三、抽象类"></a>三、抽象类</h3><ul><li>抽象类中可能不含有抽象方法，但含有抽象方法的类一定是抽象类</li><li>抽象类不能被实例化，但可以有构造函数</li><li>子类必须实现父类所有的抽象方法，除非子类也是抽象类</li><li>通过子类调用父类非抽象方法</li></ul><h3 id="四、接口"><a href="#四、接口" class="headerlink" title="四、接口"></a>四、接口</h3><ul><li>接口是一种不同于类的引用类型，是一系列抽象方法的集合；</li><li>方法默认为<code>public abstract</code>,变量默认为<code>public static final</code>，接口中的成员变量可以直接通过<code>接口名调用</code></li></ul><h4 id="接口的功能"><a href="#接口的功能" class="headerlink" title="接口的功能"></a>接口的功能</h4><blockquote><ul><li>1.接口提供了一组功能的命名集合，一个类通过实现接口的方式，从而获得接口所声明的抽象方法。</li><li>2.接口定义了不同类交互的标准(一个类可以调用另一个类(实现了某个接口)的接口方法)</li></ul></blockquote><h4 id="接口与抽象类的区别"><a href="#接口与抽象类的区别" class="headerlink" title="接口与抽象类的区别"></a>接口与抽象类的区别</h4><ul><li>抽象层次不同<blockquote><p>抽象类是对类抽象，而接口是对行为的抽象</p></blockquote></li><li>设计层次不同<blockquote><p>抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。</p></blockquote></li></ul><h3 id="五、多态"><a href="#五、多态" class="headerlink" title="五、多态"></a>五、多态</h3><ul><li>定义：<blockquote><p>在代码中为同一名称的方法（接口）提供不同的实现，<br>为一组类提供了统一的交互接口，又保留了类间的差异。</p></blockquote></li><li>类型</li></ul><blockquote><ul><li>编译时多态：方法的重载</li><li>运行时多态 :<blockquote><p>程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程 时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实 例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运 行期间才能决定。</p></blockquote></li></ul></blockquote><ul><li>如何使用多态<blockquote><ul><li>为一组类抽象出公共父类或者接口</li><li>统一方法名</li></ul></blockquote></li><li>好处：统一接口，更易于扩展</li><li>重写原则：<blockquote><ul><li>参数列表完全一致</li><li>子类返回类型小于等于父类方法返回类型，</li><li>子类抛出异常小于等于父类方法抛出异常，</li><li>子类访问权限大于等于父类方法访问权限。</li></ul></blockquote></li></ul><h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><p><img src="https://gitee.com/huster_ning/image/raw/master/image/io.PNG" srcset="/img/loading.gif" alt="io"></p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><ul><li>减少了cast带来的运行时异常，<br>使算法和框架更为通用，减少了冗余代码</li><li>泛型方法<blockquote><ul><li>所有泛型方法声明都有一个类型<code>参数声明</code>部分（由尖括号分隔），该类型参数声明部分在方 法返回类型之前。</li><li>泛型方法体的声明和其他方法一样。注意类型参数<code>只能代表引用型类型</code>(只能是类)，不能是<code>基本类型</code>(比如int 、double)。</li></ul></blockquote></li><li>通配符<blockquote><ul><li>&lt;? extends T&gt; 上界为T</li><li>&lt;? super T&gt;   下界为T</li><li><e extends="" comparable<e="">&gt; : <strong>类型 E 必须实现 Comparable 接口</strong>，并且这个接口的类型是 E</e></li></ul></blockquote></li><li>使用泛型进行排序<div class="hljs"><pre><code class="hljs java">   <span class="hljs-comment">//使用Comparable接口确保E能够进行比较</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E extends Comparable&lt;E&gt;&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(E[] a)</span> </span>&#123; <span class="hljs-keyword">int</span> n = a.length;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;n-<span class="hljs-number">1</span>; i++)&#123; <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j&lt;n-<span class="hljs-number">1</span>; j++)&#123; <span class="hljs-comment">//使用compareTo()方法进行比较</span><span class="hljs-keyword">if</span>(a[j].compareTo(a[j+<span class="hljs-number">1</span>]) &gt; <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//为什么可以使用接口的compareTo()方法，因为大部分类都已经实现了Comparable接口，否则自己直接在E中实现Comparable接口即可</span>E temp = a[j]; a[j] = a[j+<span class="hljs-number">1</span>];a[j+<span class="hljs-number">1</span>] = temp;&#125; &#125; &#125; &#125;</code></pre></div></li></ul><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>Throwable 类中定义的方法：</p><ul><li>getMessage()：获得详细的异常信息 </li><li>toString()：获得异常的简短描述 </li><li>printStackTrace()：打印异常发生处栈跟踪信息，包括类名、方法名和所在行数<blockquote><p>用 throws 关键字指出可能出现的异常类型，自己不进行处理，由该函数的调用者处理</p></blockquote></li></ul><p><img src="https://gitee.com/huster_ning/image/raw/master/image/exception.PNG" srcset="/img/loading.gif" alt="exception"></p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><p><img src="https://gitee.com/huster_ning/image/raw/master/image/thread.PNG" srcset="/img/loading.gif" alt="thread"> </p><h3 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h3><p><img src="https://gitee.com/huster_ning/image/raw/master/image/%E5%90%AF%E5%8A%A8%E7%BA%BF%E7%A8%8B.png" srcset="/img/loading.gif" alt="启动线程"></p><h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2><h3 id="类的关系"><a href="#类的关系" class="headerlink" title="类的关系"></a>类的关系</h3><blockquote><p><code>1+3+1</code>: 继承(泛化)、关联、聚合、组合、依赖</p><blockquote><ul><li>聚合：关联的特例，是一种整体与部分的关系（has a）,但不是<code>must has a</code>的关系</li><li>组合：组合也是关联关系的一种特例，他体现的是一种<code>contains-a</code>的关系，这种关系比聚 合更强，也称为强聚合。</li></ul></blockquote></blockquote><h3 id="常见图模型"><a href="#常见图模型" class="headerlink" title="常见图模型"></a>常见图模型</h3><h4 id="静态模型："><a href="#静态模型：" class="headerlink" title="静态模型："></a>静态模型：</h4><ul><li>用例图（Use Case Diagram）：从用户角度描述系统功能。<blockquote><p>用例图的描述：</p><blockquote><ul><li>简要说明</li><li>主事件流和其他事件流 </li><li>前提条件 </li><li>事后条件</li></ul></blockquote></blockquote></li><li>类图（ClassDiagram）：描述对象模型中类与类之间的关系。 </li><li>组件图（ComponentDiagram）：描述系统中各个组件之间的依赖关系，还可以描 述组件的源代码组织结构。 </li><li>部署图（DeploymentDiagram）：定义系统中软硬件的物理体系结构。</li></ul><h4 id="动态态模型："><a href="#动态态模型：" class="headerlink" title="动态态模型："></a>动态态模型：</h4><ul><li>时序图（Sequence Diagram）：显示对象之间的动态协作关系，强调对象之间消息 发送的时间顺序。 <blockquote><p>时序图的构成：</p><ul><li>对象生命线（垂直的虚线）； </li><li>对象激活框（细长矩形）；</li><li>消息（带箭头的水平线 + 消息名）； </li><li>调用：实线段，实心箭头 </li><li>返回：虚线段，枝状箭头  </li><li>顶部方框表示类的对象或类，有3种写法            <blockquote><ol><li>对象名和类名间用冒号隔开，如 c：Car;</li><li>省略对象名称，：Car ;</li><li>只保留对象名，c。</li></ol></blockquote></li></ul></blockquote></li></ul><p><br><br><img src="/2018/10/28/java复习笔记/D:%5Chexo%5Csource%5C_posts%5Cjava%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%5Csequence.PNG" srcset="/img/loading.gif" alt="sequence"><br><br></p><ul><li>活动图（Activity Diagram）：显示活动的顺序控制流。</li><li>状态转换图（StateTransitionDiagram）：描述对象所有可能的状态，以及导致状 态转换的条件。</li></ul><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="1-SOLID原则"><a href="#1-SOLID原则" class="headerlink" title="1.SOLID原则"></a>1.SOLID原则</h3><blockquote><ul><li>单一职责原则 Single Responsibility Principle</li><li>开放闭合原则 Open Closed Principle</li><li>Liskov替换原则 Liskov Substitution Principle</li><li>接口隔离原则 Interface Segregation Principle</li><li>依赖倒置原则 Dependency Inversion Principle </li></ul></blockquote><h3 id="2-OOD模式实例"><a href="#2-OOD模式实例" class="headerlink" title="2.OOD模式实例"></a>2.OOD模式实例</h3><h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><ul><li>实例: JButton与ActionListener、气象站</li><li>定义：观察者模式定义了对象之间的一对多依赖，当一个对象改变状态时， 它的所有依赖者都会收到通知并自动更新。</li></ul><h4 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h4><ul><li>实例：咖啡店、java io</li><li>定义：装饰者模式动态地将责任附加到对象上。 若要扩展功能，装饰者提供了比继承更 有弹性的替代方案。</li><li>特点：<blockquote><ul><li>装饰者和被装饰对象拥有相同的超类型。</li><li>可以用一个或者多个装饰者包装一个对象。</li><li>装饰者可以在被装饰对象的行为前/后加上 自己的行为，以达到特定的目的。</li><li>装饰过程可以在运行时动态地完成。</li></ul></blockquote></li></ul><h3 id="3-OOD架构"><a href="#3-OOD架构" class="headerlink" title="3.OOD架构"></a>3.OOD架构</h3><h4 id="模型-视图-控制器-Model-View-Controller-MVC"><a href="#模型-视图-控制器-Model-View-Controller-MVC" class="headerlink" title="模型-视图-控制器 Model-View-Controller (MVC)"></a>模型-视图-控制器 Model-View-Controller (MVC)</h4><h4 id="三层程序设计模型-Three-tier-design-model"><a href="#三层程序设计模型-Three-tier-design-model" class="headerlink" title="三层程序设计模型 Three-tier design model"></a>三层程序设计模型 Three-tier design model</h4><ul><li>表示层 （用户界面）</li></ul><blockquote><ul><li>GUI class </li><li>显示数据，接收操作</li></ul></blockquote><ul><li>业务逻辑层 （问题域层）</li></ul><blockquote><ul><li>PD class </li><li>从用户界面接收请求，根据业务逻辑处理请求，从DA类获得数据/向DA类发 送数据，将处理结果送回表示层</li></ul></blockquote><ul><li>数据访问层<blockquote><ul><li>DA class </li><li>建立与数据库的连接，完成增删改查，关闭连接。</li></ul></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Map的遍历与排序</title>
    <link href="/2018/10/16/Map%E7%9A%84%E9%81%8D%E5%8E%86%E4%B8%8E%E6%8E%92%E5%BA%8F/"/>
    <url>/2018/10/16/Map%E7%9A%84%E9%81%8D%E5%8E%86%E4%B8%8E%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>引言：集合是java比较重要的一个知识点，而集合的遍历尤为重要。<br>  相对来说，Map又是集合中比较难懂的一部分，故今天来讲一下Map的<br>  遍历与排序。</p></blockquote><h2 id="Map的遍历"><a href="#Map的遍历" class="headerlink" title="Map的遍历"></a>Map的遍历</h2><ul><li><p>较为简单的遍历方法可以通过<code>keySet()</code>方法获取Map中的所有的<code>key</code>,<br>然后使用<code>get(key)</code>获取<code>key</code>对应的<code>value</code>,代码如下：</p><div class="hljs"><pre><code class="hljs java"> Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;String, String&gt;(); map.put(<span class="hljs-string">"1"</span>,<span class="hljs-string">"xinger"</span>); <span class="hljs-comment">//······省略部分代码</span><span class="hljs-keyword">for</span>(String s : map.keySet())&#123;System.out.println(<span class="hljs-string">"key:"</span>+s+<span class="hljs-string">","</span>+<span class="hljs-string">"value:"</span>+map.get(s));&#125;</code></pre></div></li></ul><a id="more"></a><ul><li><p>通过Map.entrySet()遍历map：Map.entrySet()方法返回该地图的集合视图(<code>Set(Map.Entry&lt;K,V&gt;)</code>)</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(Map.Entry&lt;String, String&gt; entry : map.entrySet())&#123;  <span class="hljs-comment">//参数类型请灵活处理</span>System.out.println(<span class="hljs-string">"key:"</span>+entry.getKey()+<span class="hljs-string">","</span>+<span class="hljs-string">"value:"</span>+entry.getValue());&#125;</code></pre></div></li><li><p>通过迭代器遍历Map:</p><div class="hljs"><pre><code class="hljs java">Iterator(Map.Entry&lt;String, String&gt;) ite = map.entrySet().iterator();<span class="hljs-keyword">while</span>(ite.hasNext())&#123;Map.Entry&lt;String, String&gt; entry = ite.next();System.out.println(<span class="hljs-string">"key:"</span>+entry.getKey()+<span class="hljs-string">","</span>+<span class="hljs-string">"value:"</span>+entry.getValue());z&#125;</code></pre></div></li></ul><h2 id="Map的排序"><a href="#Map的排序" class="headerlink" title="Map的排序"></a>Map的排序</h2><ul><li><p>利用TreeMap类进行排序：<code>TreeMap</code>是默认按<code>key</code>的升序排序，若要改变排序方式，需要使用<strong>比较器</strong>：<code>Comparator</code><br>并使用构造器<code>TreeMap(Comparator&lt;? super K&gt; comparator)</code>,注意到泛型<code>? super K</code>,故本质还是进行按<code>key</code>排序。</p><div class="hljs"><pre><code class="hljs java">Map&lt;String,String&gt; map = <span class="hljs-keyword">new</span> TreeMap&lt;String, String&gt;(<span class="hljs-keyword">new</span> Comparator&lt;String&gt;()&#123;                <span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(String o1, String o2)</span> </span>&#123;<span class="hljs-keyword">return</span>  o2.compareTo(p1);&#125;);</code></pre></div></li><li><p>Map按value排序：实现Comparator接口，并重写<code>compare(Object o1, Object o2)</code>方法</p><div class="hljs"><pre><code class="hljs java">List&lt;Map.Entry&lt;String, Integer&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Map.Entry&lt;String, Integer&gt;&gt;(map.entrySet());   <span class="hljs-comment">//排序</span>   Collections.sort(list, <span class="hljs-keyword">new</span> Comparator&lt;Map.Entry&lt;String, Integer&gt;&gt;()&#123;<span class="hljs-comment">//内部类</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Entry&lt;String, Integer&gt; o1, Entry&lt;String, Integer&gt; o2)</span> </span>&#123;<span class="hljs-keyword">return</span> o2.getValue() - o1.getValue();&#125;      &#125;);</code></pre></div></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Collection</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jdbc</title>
    <link href="/2018/10/05/jdbc/"/>
    <url>/2018/10/05/jdbc/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-JDBC连接MySql"><a href="#1-JDBC连接MySql" class="headerlink" title="1.JDBC连接MySql"></a>1.JDBC连接MySql</h1><p>首先新建一个数据库，<code>create database new_database</code>,<code>use new_database</code>,<code>create new_table(.....)</code>,注意mysql命令<br>要有冒号作为一个语句的结束，然后需要下载驱动包，<a href="http://downloads.mysql.com/archives/c-j/" target="_blank" rel="noopener">http://downloads.mysql.com/archives/c-j/</a>, 解压导入到项目中即可</p><p><font color="#DC1818">注意：下面的代码中的<code>Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;)</code>    注册驱动文件 ，与网上的教程<code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code>有所区别，是由于驱动包版本不同所致，请注意区分</font><br><a id="more"></a><br><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.sql.*;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySql</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String url = <span class="hljs-string">"jdbc:mysql://localhost:3306/database_name?useSSL=false"</span>;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String user = <span class="hljs-string">"root"</span>;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String password = <span class="hljs-string">"xxxxxxx"</span>;<span class="hljs-comment">//the password of your mysql;</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;Connection con = <span class="hljs-keyword">null</span>; Statement statement = <span class="hljs-keyword">null</span>; <span class="hljs-keyword">try</span> &#123; <span class="hljs-comment">//注册驱动文件</span> Class.forName(<span class="hljs-string">"com.mysql.cj.jdbc.Driver"</span>);  <span class="hljs-comment">//连接数据库</span> con = DriverManager.getConnection(url, user, password);<span class="hljs-comment">//查询</span> statement = con.createStatement(); String sql = <span class="hljs-string">"update websites set name='xinger' where id=6;"</span>; <span class="hljs-comment">//update</span> System.out.println(statement.executeUpdate(sql));  <span class="hljs-comment">//System.out.println(ret.toString());</span> sql = <span class="hljs-string">"select * from websites"</span>; ResultSet rs = statement.executeQuery(sql); <span class="hljs-keyword">while</span>(rs.next())&#123;         <span class="hljs-comment">//Retrieve by column name</span>         <span class="hljs-keyword">int</span> id  = rs.getInt(<span class="hljs-string">"id"</span>);         String name = rs.getString(<span class="hljs-string">"name"</span>);         String url = rs.getString(<span class="hljs-string">"url"</span>);         String country = rs.getString(<span class="hljs-string">"country"</span>);         <span class="hljs-comment">//Display values</span>         System.out.print(<span class="hljs-string">"id: "</span> + id);         System.out.print(<span class="hljs-string">",name:"</span> + name);         System.out.print(<span class="hljs-string">", url: "</span> + url);         System.out.println(<span class="hljs-string">", country: "</span> + country);      &#125; rs.close(); statement.close(); con.close();  &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123; System.out.println(e); &#125;  <span class="hljs-keyword">catch</span> (SQLException e) &#123; e.printStackTrace();&#125; &#125;&#125;</code></pre></div></p><h1 id="2-Statement接口"><a href="#2-Statement接口" class="headerlink" title="2.Statement接口"></a>2.Statement接口</h1><p>   需要使用<code>Connection</code>对象的<code>createStatement()</code>方法创建一个<code>Statement</code>对象；<br>   <code>Statement</code>中的方法：</p><p> <font color="#1EE4F1">boolean execute (String SQL)</font> 如果可以检索到ResultSet对象，则返回一个布尔值true; 否则返回false。使用此方法执行SQLDDL语句或需要使用真正的动态SQL，可使用于执行创建数据库，创建表的SQL语句等等。</p><p><font color="#1EE4F1">int executeUpdate (String SQL)</font>:返回受SQL语句执行影响的行数。使用此方法执行预期会影响多行的SQL语句，例如:INSERT，<br>UPDATE或DELETE语句。</p><p><font color="#1EE4F1">ResultSet executeQuery(String SQL)</font>：返回一个ResultSet对象。 当您希望获得结果集时，请使用此方法，就像使用SELECT语<br>句一样。</p>]]></content>
    
    
    
    <tags>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo搭建个人博客系统</title>
    <link href="/2018/10/05/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/"/>
    <url>/2018/10/05/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Hexo-GitHub搭建个人博客"><a href="#Hexo-GitHub搭建个人博客" class="headerlink" title="Hexo+GitHub搭建个人博客"></a>Hexo+GitHub搭建个人博客</h1><h2 id="1-Hexo搭建GitHub-Pages"><a href="#1-Hexo搭建GitHub-Pages" class="headerlink" title="1.Hexo搭建GitHub Pages"></a>1.Hexo搭建GitHub Pages</h2><p>由于大部分过程官方文档中都有详细说明，本文不在讲述。我主要讲述一下如何搭建GitHub Pages:<br>首先在Hexo目录下找到配置文件_config.yml,然后修改deploy中的内容:</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attribute">deploy</span>:  <span class="hljs-attribute">type</span>: git  <span class="hljs-attribute">repo</span>: <span class="hljs-attribute">https</span>:<span class="hljs-comment">//github.com/your_github_name/your_github_name.github.io.git</span>  <span class="hljs-attribute">branch</span>: master</code></pre></div><p>其中repo是你的github仓库网址<br>最后使用命令hexo s 生成静态文件，hexo d 发布博客</p><a id="more"></a><h2 id="2-更换博客主题"><a href="#2-更换博客主题" class="headerlink" title="2.更换博客主题"></a>2.更换博客主题</h2><p>   <a href="https://hexo.io/themes/" target="_blank" rel="noopener">themes</a>这个是官网提供的主题，而本人使用的主题是华科大佬写的<br><a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">hexo-theme-yilia</a>,比较美观，使用也比较方便。<br>    首先<code>git clone</code>到<code>themes</code>文件夹中，然后在主目录的<code>_config.yml</code><br>中找到theme,改成你说下载的theme名字即可，如图：<br><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-built_in">theme</span>: hexo-<span class="hljs-built_in">theme</span>-yilia</code></pre></div></p><p>最后<code>git pull</code>就好了</p><h2 id="3-在博客中加载图片"><a href="#3-在博客中加载图片" class="headerlink" title="3.在博客中加载图片"></a>3.在博客中加载图片</h2><p> 在<code>_config.yml</code>中找到<code>Writing</code>部分，将<code>post_asset_folder</code>改为<code>true</code>,<br> 这样每次<code>hexo new &quot;blog name&quot;</code>时都会自动新建一个同名的资源文件夹，将需<br> 要加载的图片放到该文件夹中,在博客中引用该图片就行了</p> <div class="hljs"><pre><code class="hljs undefined">&#123;% img [class names] image.jpg [width] [height] [title text [alt text]] %&#125;</code></pre></div><p>也可以这样引用<code>![](image.jpg)</code>(直接输入图片文件名即可)，但这个无法在首页中显示</p><h2 id="4-更换博客域名"><a href="#4-更换博客域名" class="headerlink" title="4.更换博客域名"></a>4.更换博客域名</h2><p> 作为一个学生党，直接买域名对我来说还是有点小贵，但GitHub给学生提供了一个开发大礼包，学生可以用学校的邮箱进行认证，<br><a href="https://education.github.com/" target="_blank" rel="noopener">申请网址</a>。这个开发大礼包中，对我来说主要有两个比较有用的东西，第一个就是学生可以<br>无限创建私有仓库，另外，可以使用<code>namaCheap</code>申请一个一年的免费域名(<code>.me</code>的顶级域名)，<a href="https://nc.me/" target="_blank" rel="noopener">申请网址</a>，<br>申请到域名后，就可以自定义设置<code>github pages</code>的域名了(代替<code>github.io</code>的域名)，具体操作参考<a href="https://help.github.com/articles/using-a-custom-domain-with-github-pages/" target="_blank" rel="noopener">git pages 官方文档</a> </p><h3 id="4-1-github-pages-with-https"><a href="#4-1-github-pages-with-https" class="headerlink" title="4.1 github pages with https"></a>4.1 github pages with https</h3><p>官方说明：<a href="https://help.github.com/en/github/working-with-github-pages/securing-your-github-pages-site-with-https" target="_blank" rel="noopener">github-pages=with-https</a></p><p>在repository的设置中勾选<code>Enforce HTTPS</code>即可，如果不能勾选，等一段时间即可。</p><p><img src="https://gitee.com/huster_ning/image/raw/master/image/Snipaste_2020-05-22_13-55-31.jpg" srcset="/img/loading.gif" alt="Snipaste_2020-05-22_13-55-31"></p><h3 id="4-2-更换域名的一些坑"><a href="#4-2-更换域名的一些坑" class="headerlink" title="4.2 更换域名的一些坑"></a>4.2 更换域名的一些坑</h3><ul><li><p>域名解析添加CNAME记录：</p><p><img src="https://gitee.com/huster_ning/image/raw/master/image/Snipaste_2020-05-22_13-15-10.jpg" srcset="/img/loading.gif" alt="Snipaste_2020-05-22_13-15-10"></p><p> CNAME:规范名字，允许将多个名字映射到同一台计算机上，即你可以使用多个域名指向同一服务器IP，在这里就是你既可以通过<br>‘github.io’这个域名，又可以通过<code>.me</code>域名访问你的博客。为了保证可以用两个域名访问同一个博客，应该新建一个<code>CNAME</code>文件<br>我新建文件的位置：<br><img src="https://gitee.com/huster_ning/image/raw/master/image/CNAME.PNG" srcset="/img/loading.gif" alt="CNAME"></p></li></ul><p>并写入你的域名，然后提交到github上去，如果直接在github中新建，之后提交博客可能<code>覆盖</code>该文件，导致博客无法访问</p><h2 id="5-插入视频"><a href="#5-插入视频" class="headerlink" title="5.插入视频"></a>5.插入视频</h2><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"560"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"315"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://www.youtube.com/embed/Ilg3gGewQ5U"</span> <span class="hljs-attr">frameborder</span>=<span class="hljs-string">"0"</span> <span class="hljs-attr">allowfullscreen</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span></code></pre></div><iframe width="60%" height="315" display="block" src="https://www.youtube.com/embed/Ilg3gGewQ5U" frameborder="0" allowfullscreen></iframe><h2 id="6-写博客"><a href="#6-写博客" class="headerlink" title="6.写博客"></a>6.写博客</h2><p>使用如下命令创建一篇新的文章：<br><div class="hljs"><pre><code class="hljs undefined">hexo <span class="hljs-keyword">new</span> [layout] &lt;<span class="hljs-built_in">title</span>&gt;</code></pre></div></p><p>文章有三种布局：post、page、draft，默认布局是post，draft布局在部署时不发布，可以使用<code>hexo public</code>进行发布，不同的布局保存在不同的文件夹下。</p><div class="table-container"><table><thead><tr><th>布局</th><th>目录</th></tr></thead><tbody><tr><td>post</td><td>source/_posts</td></tr><tr><td>draft</td><td>source/_drafts</td></tr><tr><td>page</td><td>source</td></tr></tbody></table></div><p>本文主要参考了<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">hexo 文档</a><code>&amp;</code><a href="https://github.com/litten/BlogBackup" target="_blank" rel="noopener">BlogBackup</a></p><h1 id="服务器部署Hexo博客系统"><a href="#服务器部署Hexo博客系统" class="headerlink" title="服务器部署Hexo博客系统"></a>服务器部署Hexo博客系统</h1><p>部署原理很简单，实际上就是将Hexo生成的public目录上传到了服务器上。在服务器上面需要完成的工作：创建一个git用户、创建git裸仓库、配置钩子函数、nginx配置；在本地需要完成的工作：修改配置文件的部署信息、配置免密登录。</p><h2 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h2><p>创建一个名为<code>git</code>的普通用户，而不是使用root用户，是为了限制用户的权限。创建用户的过程可以<a href="https://www.ningxin.site/2020/07/04/Linux用户" target="_blank" rel="noopener">参考</a></p><h2 id="创建git裸仓库配置钩子函数"><a href="#创建git裸仓库配置钩子函数" class="headerlink" title="创建git裸仓库配置钩子函数"></a>创建git裸仓库配置钩子函数</h2><p>裸仓库只包括<code>.git</code>文件，主要是关于仓库的修改信息，而不包括工作树。如下创建一个<code>blog.git</code>的仓库</p><div class="hljs"><pre><code class="hljs undefined">git init <span class="hljs-comment">--bare blog.git</span></code></pre></div><p>使用钩子函数是为了从裸仓库中恢复工作树。在<code>blog.git/hooks/</code>目录下创建<code>post-receive</code>文件, 即使用<code>post-receive</code>钩子，<code>post-receive</code>钩子是服务端钩子，在整个过程完成后运行，具体可以参考<a href="[https://www.git-scm.com/book/zh/v2/%E8%87%AA%E5%AE%9A%E4%B9%89-Git-Git-%E9%92%A9%E5%AD%90](https://www.git-scm.com/book/zh/v2/自定义-Git-Git-钩子">git钩子</a>)。然后在<code>post-receive</code>文件中写入以下内容：</p><div class="hljs"><pre><code class="hljs undefined">git <span class="hljs-attribute">--work-tree</span>=blog <span class="hljs-attribute">--git-dir</span>=blog.git checkout -f</code></pre></div><h2 id="修改配置信息"><a href="#修改配置信息" class="headerlink" title="修改配置信息"></a>修改配置信息</h2><p>在<code>_config.yml</code>文件中修改deploy中的信息：</p><div class="hljs"><pre><code class="hljs yml"><span class="hljs-attr">deploy:</span><span class="hljs-attr">  type:</span> <span class="hljs-string">git</span><span class="hljs-attr">  repo:</span> <span class="hljs-string">git@服务器IP地址:仓库地址</span><span class="hljs-attr">  branch:</span> <span class="hljs-string">master</span></code></pre></div><h2 id="ssh免密登录"><a href="#ssh免密登录" class="headerlink" title="ssh免密登录"></a>ssh免密登录</h2><p>在本地<code>Git Bash</code>中使用<code>ssh-keygen</code>命令生成密钥，默认保存在<code>C:/users/username/.ssh/id_rsa</code>目录中。使用<code>ssh-copy-id -i</code>将<code>id_rsa.pub</code>（即公钥）添加到服务器。</p><div class="hljs"><pre><code class="hljs powershell">ssh-copy-id -i ~/.ssh/id_rsa.pub your_user_name@HostIP  //添加公钥ssh your_user_name@HostIP //验证是否添加成功</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>github</tag>
      
      <tag>博客搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
