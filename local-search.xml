<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>虚拟机搭建Hadoop过程记录</title>
    <link href="/2020/06/07/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%90%AD%E5%BB%BAHadoop%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/06/07/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%90%AD%E5%BB%BAHadoop%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-搭建Hadoop分布式集群环境"><a href="#1-搭建Hadoop分布式集群环境" class="headerlink" title="1. 搭建Hadoop分布式集群环境"></a>1. 搭建Hadoop分布式集群环境</h1><h2 id="1-1-安装Linux虚拟机"><a href="#1-1-安装Linux虚拟机" class="headerlink" title="1.1 安装Linux虚拟机"></a>1.1 安装Linux虚拟机</h2><p>首先下载并安装VirtualBox 6.1.8，然后准备安装Linux虚拟机，需要提前下载好镜像文件，我下载的是<code>ubuntu-16.04.6-server-amd64.iso</code>。然后新建一个虚拟机，分配1G内存，10G虚拟空间。在新建虚拟机之后，需要注意以下设置：</p><ul><li>设置启动顺序：如下图所示，将光驱启动调到最前面。</li></ul><a id="more"></a><p><img src="http://image.ningxin.site/20200603230721.png" srcset="/img/loading.gif" alt=""></p><ul><li>如下选择镜像文件的存放位置：</li></ul><p><img src="http://image.ningxin.site/20200603230506.png" srcset="/img/loading.gif" alt=""></p><p>完成上述操作后，点击运行进行虚拟机的安装。重复操作，安装如下四台虚拟机，其中ubuntu作为master，slave1、slave2、slave3作为slave。</p><p><img src="http://image.ningxin.site/20200603231706.png" srcset="/img/loading.gif" alt=""></p><h2 id="1-2-配置Hadoop环境"><a href="#1-2-配置Hadoop环境" class="headerlink" title="1.2 配置Hadoop环境"></a>1.2 配置Hadoop环境</h2><h3 id="1-2-3-前置条件"><a href="#1-2-3-前置条件" class="headerlink" title="1.2.3 前置条件"></a>1.2.3 前置条件</h3><h4 id="1-2-3-1-编辑hostname文件"><a href="#1-2-3-1-编辑hostname文件" class="headerlink" title="1.2.3.1 编辑hostname文件"></a>1.2.3.1 编辑hostname文件</h4><p>使用<code>hostnamectl set-hostname</code>命令设置hostname分别为master、slave1、slave2、slave3</p><p><img src="http://image.ningxin.site/20200603232421.png" srcset="/img/loading.gif" alt=""></p><h4 id="1-2-3-2-编辑hosts文件"><a href="#1-2-3-2-编辑hosts文件" class="headerlink" title="1.2.3.2 编辑hosts文件"></a>1.2.3.2 编辑hosts文件</h4><p>hosts文件用来记录IP和hostname之间的对应关系。使用<code>ifconfig</code>命令来查看IP地址，最后发现4台虚拟机的IP地址是一样的，需要修改网线连接方式，如下选择<code>桥接网卡</code>即可：<br><img src="http://image.ningxin.site/20200603232752.png" srcset="/img/loading.gif" alt=""></p><p>然后修改<code>/etc/hosts</code>文件，如下所示：</p><p><img src="http://image.ningxin.site/20200603232949.png" srcset="/img/loading.gif" alt=""></p><h4 id="1-2-3-3-配置ssh免密登录"><a href="#1-2-3-3-配置ssh免密登录" class="headerlink" title="1.2.3.3 配置ssh免密登录"></a>1.2.3.3 配置ssh免密登录</h4><p>在master上使用<code>ssh-keygen -t rsa</code>命令生成密钥（保存在<code>~/.ssh</code>目录下），然后将公钥上传到slave的<code>~/.ssh/authorized_keys</code>中即可。</p><h2 id="1-2-安装并配置jdk"><a href="#1-2-安装并配置jdk" class="headerlink" title="1.2 安装并配置jdk"></a>1.2 安装并配置jdk</h2><p>首先在Windows上下载<code>jdk-8u251-linux-x64.tar.gz</code>，然后使用pscp工具上传到Linux虚拟机上。</p><p><img src="http://image.ningxin.site/20200602154744.png" srcset="/img/loading.gif" alt=""></p><p>将jdk解压在<code>/usr/java/</code>目录下，然后配置java环境变量，在<code>/etc/profile</code>文件中添加如下内容，然后运行<code>source /etc/profile</code>命令使环境变量生效：</p><pre><code class="hljs undefined">export JAVA_HOME=<span class="hljs-regexp">/usr/java</span><span class="hljs-regexp">/jdk1.8.0_251export CLASSPATH=.:$CLASSPATH:$JAVA_HOME/</span><span class="hljs-symbol">LIB:</span>$JAVA_HOME/jre/<span class="hljs-class"><span class="hljs-keyword">lib</span></span>export PATH=$<span class="hljs-symbol">PATH:</span>$JAVA_HOME/<span class="hljs-symbol">bin:</span>$JAVA_HOME/jre/bin</code></pre><h2 id="1-3-安装并配置Hadoop"><a href="#1-3-安装并配置Hadoop" class="headerlink" title="1.3 安装并配置Hadoop"></a>1.3 安装并配置Hadoop</h2><h3 id="1-3-1-配置环境变量"><a href="#1-3-1-配置环境变量" class="headerlink" title="1.3.1 配置环境变量"></a>1.3.1 配置环境变量</h3><p>先从Windows上下载Hadoop2.10.0并上传到Linux虚拟机上，解压到<code>/usr/hadoop/</code>目录下，然后添加如下环境变量：</p><pre><code class="hljs undefined"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">HADOOP_HOME</span>=/usr/hadoop/hadoop-2.10.0<span class="hljs-builtin-name">export</span> <span class="hljs-attribute">PATH</span>=<span class="hljs-variable">$PATH</span>:$HADOOP_HOME/bin:$HADOOP_HOME/sbin</code></pre><h3 id="1-3-2-配置相关配置文件"><a href="#1-3-2-配置相关配置文件" class="headerlink" title="1.3.2 配置相关配置文件"></a>1.3.2 配置相关配置文件</h3><p>以下提到的配置文件都位于<code>etc/hadoop/</code>目录下。</p><p><img src="http://image.ningxin.site/20200604105619.png" srcset="/img/loading.gif" alt=""></p><p>注意：只需要修改master中的Hadoop配置文件，然后将配置好的Hadoop上传到slave中去即可，避免重复配置的麻烦。</p><h4 id="1-3-2-1-hadoop-env-sh-和-yarn-env-sh"><a href="#1-3-2-1-hadoop-env-sh-和-yarn-env-sh" class="headerlink" title="1.3.2.1 hadoop-env.sh 和 yarn-env.sh"></a>1.3.2.1 hadoop-env.sh 和 yarn-env.sh</h4><p>两个文件都是修改<code>JAVA_HOME</code>的值，需要使用实际的路径，而不是环境变量。<br><img src="http://image.ningxin.site/20200602161801.png" srcset="/img/loading.gif" alt=""></p><h4 id="1-3-2-2-core-site-xml"><a href="#1-3-2-2-core-site-xml" class="headerlink" title="1.3.2.2 core-site.xml"></a>1.3.2.2 core-site.xml</h4><p>配置监听端口和缓存目录，缓存目录不存在则需要创建。</p><pre><code class="hljs undefined"><span class="hljs-params">&lt;configuration&gt;</span><span class="hljs-meta"># HDFS Web UI 监听端口配置</span><span class="hljs-params">&lt;property&gt;</span><span class="hljs-params">&lt;name&gt;</span>fs.defaultFS<span class="hljs-params">&lt;/name&gt;</span><span class="hljs-params">&lt;value&gt;</span>hdfs:<span class="hljs-comment">//master:8020&lt;/value&gt;</span><span class="hljs-params">&lt;/property&gt;</span><span class="hljs-meta"># hadoop 缓存目录，更改为自己的目录（从根目录开始，不存在需创建）</span><span class="hljs-params">&lt;property&gt;</span><span class="hljs-params">&lt;name&gt;</span>hadoop.tmp.dir<span class="hljs-params">&lt;/name&gt;</span><span class="hljs-params">&lt;value&gt;</span>file:<span class="hljs-meta-keyword">/root/</span>software/hadooptmp<span class="hljs-params">&lt;/value&gt;</span><span class="hljs-params">&lt;/property&gt;</span><span class="hljs-params">&lt;/configuration&gt;</span></code></pre><h4 id="1-3-2-3-hdfs-site-xml"><a href="#1-3-2-3-hdfs-site-xml" class="headerlink" title="1.3.2.3 hdfs-site.xml"></a>1.3.2.3 hdfs-site.xml</h4><p>需要创建HDFS存储目录，namenode用来存储namenode文件，data存储datanode数据，tmp存储临时文件。</p><pre><code class="hljs undefined">usr<span class="hljs-regexp">/hadoop/</span>hadoop-<span class="hljs-number">2.10</span>.<span class="hljs-number">0</span><span class="hljs-regexp">/hdfs/</span>namenodeusr<span class="hljs-regexp">/hadoop/</span>hadoop-<span class="hljs-number">2.10</span>.<span class="hljs-number">0</span><span class="hljs-regexp">/hdfs/</span>datausr<span class="hljs-regexp">/hadoop/</span>hadoop-<span class="hljs-number">2.10</span>.<span class="hljs-number">0</span><span class="hljs-regexp">/hdfs/</span>tmp</code></pre><p><img src="http://image.ningxin.site/20200602164047.png" srcset="/img/loading.gif" alt=""></p><h4 id="1-3-2-4-mapred-site-xml"><a href="#1-3-2-4-mapred-site-xml" class="headerlink" title="1.3.2.4 mapred-site.xml"></a>1.3.2.4 mapred-site.xml</h4><p><code>mapred-site.xml</code>文件需要从<code>mapred-site.xml.template</code>使用cp命令生成：<br><code>cp mapred-site.xml.template mapred-site.xml</code>。然后设置MapReduce运行于yarn上：</p><p><img src="http://image.ningxin.site/20200602164356.png" srcset="/img/loading.gif" alt=""></p><h4 id="1-3-2-5-yarn-site-xml"><a href="#1-3-2-5-yarn-site-xml" class="headerlink" title="1.3.2.5 yarn-site.xml"></a>1.3.2.5 yarn-site.xml</h4><p><img src="http://image.ningxin.site/20200602164735.png" srcset="/img/loading.gif" alt=""></p><p>上面<code>yarn-site.xml</code>文件中将<code>hostname</code>错打成<code>hostnane</code>，最后导致Hadoop运行wordcount时，不能结束，修改后如下：</p><p><img src="http://image.ningxin.site/20200603095221.png" srcset="/img/loading.gif" alt=""></p><h4 id="1-3-2-6-slaves"><a href="#1-3-2-6-slaves" class="headerlink" title="1.3.2.6 slaves"></a>1.3.2.6 slaves</h4><p>在slaves文件中添加如下内容来设置slave：</p><pre><code class="hljs undefined"><span class="hljs-attribute">slave1</span>slave2slave3</code></pre><h3 id="1-3-3-启动Hadoop"><a href="#1-3-3-启动Hadoop" class="headerlink" title="1.3.3 启动Hadoop"></a>1.3.3 启动Hadoop</h3><p>第一次启动需要使用<code>hdfs namenode -format</code>格式化文件系统，出现“Cannot create directory /usr/hadoop/hadoop-2.10.0/hdfs/namenode/current”错误，显示无法创建current文件。无法创建目录的原因是因为<code>hadoop-2.10.0</code>的文件拥有者是<code>root</code>，直接使用<code>sudo hdfs namenode -format</code>会出现找不到命令的错误，两种解决方法：1. 使用<code>sudo su</code>切换到管理员身份；2. 修改<code>hadoop-2.10.0</code>的文件拥有者为普通用户。</p><ul><li>启动: 使用<code>start-dfs.sh</code>启动分布式文件系统。</li></ul><p><img src="http://image.ningxin.site/20200602213020.png" srcset="/img/loading.gif" alt=""></p><ul><li>jps: 使用jps命令验证HDFS是否启动成功</li></ul><p><img src="http://image.ningxin.site/20200602213149.png" srcset="/img/loading.gif" alt=""></p><ul><li>启动yarn: 使用<code>start-yarn.sh</code>启动yarn</li></ul><p><img src="http://image.ningxin.site/20200602214232.png" srcset="/img/loading.gif" alt=""></p><ul><li>浏览器: 在浏览器中输入<code>http:master:50070</code>查看UI界面</li></ul><p><img src="http://image.ningxin.site/20200602214338.png" srcset="/img/loading.gif" alt=""></p><h1 id="2-HDFS文件上传"><a href="#2-HDFS文件上传" class="headerlink" title="2. HDFS文件上传"></a>2. HDFS文件上传</h1><p>创建<code>input.txt</code>文件并输入以下内容：</p><p><img src="http://image.ningxin.site/20200604001324.png" srcset="/img/loading.gif" alt=""></p><p>使用<code>hdfs dfs -put</code>命令将文件上传到hdfs中，然后使用<code>hdfs dfs -cat</code>命令查看文件中的具体内容。</p><p><img src="http://image.ningxin.site/20200604001901.png" srcset="/img/loading.gif" alt=""></p><h1 id="3-运行wordcount程序"><a href="#3-运行wordcount程序" class="headerlink" title="3. 运行wordcount程序"></a>3. 运行wordcount程序</h1><p>wordcount程序在<code>share/hadoop/hadoop-mapreduce-examples-2.10.0.jar</code>包中, 运行该程序之前需要提前创建输入文件,输出文件不需要创建， 输入输出文件如下：</p><pre><code class="hljs undefined">/wordcount/input/<span class="hljs-selector-tag">input</span><span class="hljs-selector-class">.txt</span>/wordcount/output（不要创建）</code></pre><p>其中<code>input.txt</code>文件中的内容如下：</p><p><img src="http://image.ningxin.site/20200603100517.png" srcset="/img/loading.gif" alt=""></p><p>然后使用命令<code>hadoop jar hadoop-mapreduce-examples-2.10.0.jar wordcount /wordcount/input/input.txt /wordcount/output</code>运行wordcount程序，结果如下：<br><img src="http://image.ningxin.site/20200603100155.png" srcset="/img/loading.gif" alt=""></p><p>使用命令<code>hdfs dfs -cat /wordcount/output/part-r-00000</code>查看输出结果：<br><img src="http://image.ningxin.site/20200603100430.png" srcset="/img/loading.gif" alt=""></p><h1 id="4-编写wordcount程序"><a href="#4-编写wordcount程序" class="headerlink" title="4. 编写wordcount程序"></a>4. 编写wordcount程序</h1><p>wordcount程序见附件<code>WordCount.java</code>。</p><p>master中创建如下目录, 其中src存放java文件，classes存放class文件：</p><pre><code class="hljs undefined">~<span class="hljs-regexp">/wordcount/</span>src~<span class="hljs-regexp">/wordcount/</span>classes</code></pre><h2 id="4-1-编译"><a href="#4-1-编译" class="headerlink" title="4.1 编译"></a>4.1 编译</h2><p>编译时需要引入的包如下：</p><pre><code class="hljs undefined">share/hadoop/common/hadoop-common-<span class="hljs-number">2.10</span>.<span class="hljs-number">0</span>.jarshare/hadoop/mapreduce/hadoop-mapreduce-client-core-<span class="hljs-number">2.10</span>.<span class="hljs-number">0</span>.jarshare/hadoop/common/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">commons</span>-<span class="hljs-title">cli</span>.1.2.<span class="hljs-title">jar</span></span></code></pre><p>使用javac命令进行编译，并用<code>-classpath</code>指定引入的包，<code>-d</code>指定输出目录：</p><p><img src="http://image.ningxin.site/20200603213806.png" srcset="/img/loading.gif" alt=""></p><h2 id="4-2-打包"><a href="#4-2-打包" class="headerlink" title="4.2 打包"></a>4.2 打包</h2><p>使用命令<code>jar -cvf wordcount.jar classes/</code>进行打包：</p><p><img src="http://image.ningxin.site/20200603213924.png" srcset="/img/loading.gif" alt=""></p><h2 id="4-3-运行"><a href="#4-3-运行" class="headerlink" title="4.3 运行"></a>4.3 运行</h2><p>使用如下命令运行wordcount.jar</p><p><code>hadoop jar wordcount.jar WordCount /wordcount/input/input.txt /output</code></p><p>然后出现<code>Class WordCount$Reduce not found</code>的错误，最后使用如下打包命令，解决问题：</p><pre><code class="hljs undefined"><span class="hljs-selector-tag">jar</span> <span class="hljs-selector-tag">cf</span> <span class="hljs-selector-tag">wordcount</span><span class="hljs-selector-class">.jar</span> <span class="hljs-selector-tag">WordCount</span>*<span class="hljs-selector-class">.class</span></code></pre><p>运行界面如下：<br><img src="http://image.ningxin.site/20200603221301.png" srcset="/img/loading.gif" alt=""></p><p>运行后的输出结果如下：<br><img src="http://image.ningxin.site/20200603221509.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hadoop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3D-UNet笔记</title>
    <link href="/2020/06/03/3D-UNet%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/06/03/3D-UNet%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://arxiv.org/pdf/1606.06650.pdf" target="_blank" rel="noopener">论文地址</a></p><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><p>医学图像通常是由多个2D切片构成一整张图，对这样的数据进行标注比较困难,只能一张一张地标注2D图像，并将2D图像送进模型进行训练，但相邻的切片几乎一样，因此这样的做法效率很低。<br>论文的作者提出了3D U-Net模型，该模型主要有两种应用：</p><ul><li>semi-automated setup:  可以对只进行了稀疏标注的数据集进行训练；</li><li>fully-automated setup:  假设稀疏标注集存在，对该数据集进行训练。</li></ul><a id="more"></a><h1 id="2-网络结构"><a href="#2-网络结构" class="headerlink" title="2. 网络结构"></a>2. 网络结构</h1><p><img src="http://image.ningxin.site/20200603160416.png" srcset="/img/loading.gif" alt="网络结构"><br>该模型分为<code>analysis path</code> 和 <code>synthesis path</code>两个部分，主要结构和<code>U-Net</code>一样。</p><p><code>analysis path</code> 主要包括以下操作：该部分有4层，每一层都包含两个<code>3 x 3 x 3</code>的卷积，每次卷积之后进行<code>batch normalizetion</code>(BN) 操作和<code>ReLu</code>操作，然后进行strides为2的<code>2 x 2 x 2</code>的最大池化操作。</p><p><code>synthesis path</code> 主要包括以下操作：该部分有3层，每一层首先使用一个strides为2、卷积核为<code>2 x 2 x 2</code>的反卷积操作，然后与<code>analysis path</code>中对应的<code>fature map</code>进行cat操作，再然后是两个<code>3 x 3 x 3</code>的卷积操作，每次卷积之后进行<code>batch normalizetion</code>(BN) 操作和<code>ReLu</code>操作，然后进行strides为2的<code>2 x 2 x 2</code>的最大池化操作。</p><p>在最后一层输出时使用<code>1 x 1 x 1</code>的卷积来减少通道数。</p><p>论文中提到的一个亮点就是，3D U-Net使用了<code>weighted softmax loss function</code>将未标记的像素点设置为0以至于可以让网络可以更多地仅仅学习标注到的像素点，从而达到普适性地特点。</p><h1 id="3-训练"><a href="#3-训练" class="headerlink" title="3. 训练"></a>3. 训练</h1><p>3D U-Net采用了数据增强（data augmentation），主要是rotation、scaling和将图像设置为gray，于此同时在训练数据上和真实标注的数据上运用平滑的密集变形场(smooth dense deformation field)。</p>]]></content>
    
    
    <categories>
      
      <category>论文阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>论文阅读</tag>
      
      <tag>深度学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>V-Net笔记</title>
    <link href="/2020/05/24/V-Net%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/05/24/V-Net%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><p>V-Net用于3D图像分割（基于3D卷积），引入了新的目标函数（<code>Dice coefficient</code>）,采用<code>random non-linear transformation</code>和<code>histogram matching</code>的数据扩充方法。</p><h1 id="2-网络结构"><a href="#2-网络结构" class="headerlink" title="2. 网络结构"></a>2. 网络结构</h1><p><img src="https://gitee.com/huster_ning/image/raw/master/image/Snipaste_2020-05-27_21-15-06.jpg" srcset="/img/loading.gif" alt="Snipaste_2020-05-27_21-15-06"></p><a id="more"></a><p>网络的左侧部分由压缩路径组成，而右侧部分解压缩直到达到其原始大小。</p><h2 id="2-1-压缩路径"><a href="#2-1-压缩路径" class="headerlink" title="2.1 压缩路径"></a>2.1 压缩路径</h2><p>压缩路径中每个阶段中执行几次<code>5 x 5 x 5</code>大小的卷积操作，卷积之后使用<code>PReLU</code>函数进行非线性化操作，然后执行<code>element-wise sum</code>操作，再执行步幅为2的<code>2 x 2 x 2</code>的卷积（该步骤是使用卷积代替池化操作），将分辨率变为原来的一半。每个阶段执行完后，通道数变为原来的两倍。</p><ul><li>卷积代替池化：能够有更小的内存占用，网络性能更好</li><li>element-wise sum操作：如下图所示，首先16个x执行cat操作得到x16, 得到的x16的维度与out一致，<code>element-wise sum</code>操作就是将x16和out的对应像素点执行相加操作。</li></ul><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span><span class="hljs-params">(self, x)</span>:</span>    <span class="hljs-comment"># do we want a PRELU here as well?</span>    out = self.bn1(self.conv1(x))    <span class="hljs-comment"># split input in to 16 channels</span>    <span class="hljs-comment"># 增加通道数与out一致</span>    x16 = torch.cat((x, x, x, x, x, x, x, x,                     x, x, x, x, x, x, x, x), <span class="hljs-number">0</span>)    <span class="hljs-comment"># 执行element-wise sum操作之后在执行relu1</span>    out = self.relu1(torch.add(out, x16))    <span class="hljs-keyword">return</span> out</code></pre><h2 id="2-2-解压缩路径"><a href="#2-2-解压缩路径" class="headerlink" title="2.2 解压缩路径"></a>2.2 解压缩路径</h2><p>在解压缩路径中，与<code>U-Net</code>类似，将网络左侧部分的早期阶段提取的特征转发到右侧部分，即网络结构图中的<code>Fine-grained features forwarding</code>操作。通过这种方式，可以收集在压缩路径中丢失的细粒度细节，并且可以提高最终轮廓预测的质量。每个阶段采用反卷积操作，将分辨率提高到原来的两倍，并且通道数变为原来的一半。最后使用一个<code>1 x 1 x 1</code>的卷积得到与输入大小相同的结果，并使用softmax函数得到概率分割图。</p><ul><li><code>Fine-grained features fowarding</code>: 左侧特征图与右侧对应特征图执行拼接操作。 </li></ul><h1 id="3-Dice-loss-layer"><a href="#3-Dice-loss-layer" class="headerlink" title="3. Dice loss layer"></a>3. Dice loss layer</h1><h2 id="3-1-Dice系数"><a href="#3-1-Dice系数" class="headerlink" title="3.1 Dice系数"></a>3.1 Dice系数</h2><p>参考博客<a href="https://www.aiuai.cn/aifarm1159.html" target="_blank" rel="noopener">医学图像分割之 Dice Loss</a></p><p>Dice系数，是一种集合相似度度量函数，通常用于计算两个样本的相似度（值范围为[0, 1]）:</p><script type="math/tex; mode=display">s=\frac{2|X \bigcap Y|}{|X|+|Y|}</script><p> $|X \bigcap Y|$ 表示X 和 Y 之间的交集；|X| 和 |Y| 分别表示 X 和 Y 的元素个数. 其中，分子中的系数 2，是因为分母存在重复计算 X 和 Y 之间的共同元素的原因.</p><p>在真正计算时可以将 |X⋂Y| 近似为预测图与 GT 分割图之间的点乘，并将点乘的元素结果相加求和：</p><script type="math/tex; mode=display">|X \bigcap Y|=\left[\begin{array}{cccc}0.01 & 0.03 & 0.02 & 0.02 \\0.05 & 0.12 & 0.09 & 0.07 \\0.89 & 0.85 & 0.88 & 0.91 \\0.99 & 0.97 & 0.95 & 0.97\end{array}\right] *\left[\begin{array}{cccc}0 & 0 & 0 & 0 \\0 & 0 & 0 & 0 \\1 & 1 & 1 & 1 \\1 & 1 & 1 & 1\end{array}\right]</script><h2 id="3-2-Dice系数在医学图像分割中的应用"><a href="#3-2-Dice系数在医学图像分割中的应用" class="headerlink" title="3.2 Dice系数在医学图像分割中的应用"></a>3.2 Dice系数在医学图像分割中的应用</h2><p>在以前的损失函数中，前景区域在学习期间比背景区域更重要。在V-Net中提出了一个基于Dice系数的新的目标函数，目标是求最大值。</p><script type="math/tex; mode=display">D=\frac{2 \sum_{i}^{N} p_{i} g_{i}}{\sum_{i}^{N} p_{i}^{2}+\sum_{i}^{N} g_{i}^{2}}</script><p>其中pi为预测结果，gi为实际结果。Dice系数的梯度为：</p><script type="math/tex; mode=display">\frac{\partial D}{\partial p_{j}}=2\left[\frac{g_{j}\left(\sum_{i}^{N} p_{i}^{2}+\sum_{i}^{N} g_{i}^{2}\right)-2 p_{j}\left(\sum_{i}^{N} p_{i} g_{i}\right)}{\left(\sum_{i}^{N} p_{i}^{2}+\sum_{i}^{N} g_{i}^{2}\right)^{2}}\right]</script><h2 id="3-3-Dice系数的Pytorch实现"><a href="#3-3-Dice系数的Pytorch实现" class="headerlink" title="3.3 Dice系数的Pytorch实现"></a>3.3 Dice系数的Pytorch实现</h2><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dice_loss</span><span class="hljs-params">(pred, target)</span>:</span>    <span class="hljs-string">"""This definition generalize to real valued pred and target vector.This should be differentiable.    pred: tensor with first dimension as batch    target: tensor with first dimension as batch    """</span>smooth = <span class="hljs-number">1.</span><span class="hljs-comment"># have to use contiguous since they may from a torch.view op</span>iflat = pred.contiguous().view(<span class="hljs-number">-1</span>)tflat = target.contiguous().view(<span class="hljs-number">-1</span>)intersection = (iflat * tflat).sum()A_sum = torch.sum(iflat * iflat)B_sum = torch.sum(tflat * tflat)<span class="hljs-keyword">return</span> (<span class="hljs-number">2.</span> * intersection + smooth) / (A_sum + B_sum + smooth)</code></pre><h1 id="4-训练"><a href="#4-训练" class="headerlink" title="4. 训练"></a>4. 训练</h1><p>训练时主要采用下面的数据增强方法：</p><ul><li>使用<code>2 x 2 x 2</code>的网格控制点和<code>B-spline interpolation</code>(B样条插值)来获得稠密的形变场对图像进行非线性形变；</li><li>使用直方图匹配来获得不同的灰度分布的图像。 </li></ul>]]></content>
    
    
    <categories>
      
      <category>论文阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>论文阅读</tag>
      
      <tag>深度学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>U-net笔记</title>
    <link href="/2020/05/21/U-net%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/05/21/U-net%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="U-net"><a href="#U-net" class="headerlink" title="U-net"></a>U-net</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>U-net是对FCN的改进，主要应用于医学图像分割。</p><p>U-net的网络结构如下所示：</p><p><img src="https://gitee.com/huster_ning/image/raw/master/image/v2-96f5e828c1e83c930aa4a2bb91e64c10_r.jpg" srcset="/img/loading.gif" alt="preview"></p><a id="more"></a><p>U-net包括<code>Contracting Path</code> 和 <code>Expanding Path</code> 两个部分，所有卷积层的<code>padding = 0</code>. U-net的计算过程如下：</p><ul><li><p><code>Contracting Path</code>部分进行下采样操作：2个<code>3 x 3</code>的卷积层 + 1个 <code>2 x 2 的 max pool</code>，重复四次以上操作；</p></li><li><p><code>Expanding Path</code>部分：2个<code>3 x 3</code>卷积层 + 1个<code>2 x 2</code>反卷积操作，然后与前面对应的层使用 <strong>拼接操作</strong> 进行特征融合，重复四次以上操作；</p></li><li><p>最后经过2个<code>3 x 3</code>卷积， 1个<code>1 x 1</code>卷积(类似于残差网络，用来降维)，然后使用softmax进行输出。</p></li></ul><h3 id="特征融合"><a href="#特征融合" class="headerlink" title="特征融合"></a>特征融合</h3><p>使用concat操作进行特征融合，而不是使用相加操作进行特征融合</p><p><img src="https://gitee.com/huster_ning/image/raw/master/image/image-20200520160912870.png" srcset="/img/loading.gif" alt="image-20200520160912870"></p><h2 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h2><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>U-net使用的是带权损失函数：</p><script type="math/tex; mode=display">E = \sum_{x\in\Omega}{\omega(x)\log(p_{l(x)}(x))}</script><p>其中 $w(x)$ 指的是权重，其实就是相当于交叉熵乘了一个权重，有点不解的是我看的代码中都是直接使用<code>CrossEntropyLoss</code>进行计算loss，如下代码所示：</p><pre><code class="hljs python">unet = Unet(in_channel=<span class="hljs-number">1</span>,out_channel=<span class="hljs-number">2</span>)<span class="hljs-comment">#out_channel represents number of segments desired</span>criterion = torch.nn.CrossEntropyLoss()optimizer = torch.optim.SGD(unet.parameters(), lr = <span class="hljs-number">0.01</span>, momentum=<span class="hljs-number">0.99</span>)optimizer.zero_grad()       outputs = unet(inputs)<span class="hljs-comment"># permute such that number of desired segments would be on 4th dimension</span>outputs = outputs.permute(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>)m = outputs.shape[<span class="hljs-number">0</span>]<span class="hljs-comment"># Resizing the outputs and label to caculate pixel wise softmax loss</span>outputs = outputs.resize(m*width_out*height_out, <span class="hljs-number">2</span>)labels = labels.resize(m*width_out*height_out)loss = criterion(outputs, labels)loss.backward()optimizer.step()</code></pre><p>U-net的输入是<code>572 x 572</code>, 而输出是<code>388 x 388</code>，两者不一致，不能直接求损失函数，有两种方法：</p><ul><li>对预期输出从中心crop，使其与输出大小一致;</li><li>对输出结果进行padding操作，使其与输入大小一致。</li></ul><h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>使用梯度下降法（SGD）进行优化。</p>]]></content>
    
    
    <categories>
      
      <category>论文阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>论文阅读</tag>
      
      <tag>深度学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阿里云服务器发送邮件</title>
    <link href="/2019/07/18/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/"/>
    <url>/2019/07/18/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-在邮箱设置中开启SMTP"><a href="#1-在邮箱设置中开启SMTP" class="headerlink" title="1. 在邮箱设置中开启SMTP"></a>1. 在邮箱设置中开启SMTP</h3><p>SMTP:简单文件传输协议</p><h3 id="2-具体过程参考如下博客"><a href="#2-具体过程参考如下博客" class="headerlink" title="2. 具体过程参考如下博客"></a>2. 具体过程参考如下博客</h3><p><a href="https://yq.aliyun.com/articles/644134" target="_blank" rel="noopener">参考链接</a></p><a id="more"></a><h3 id="3-发送邮件"><a href="#3-发送邮件" class="headerlink" title="3. 发送邮件"></a>3. 发送邮件</h3><ul><li>直接输入正文<blockquote><p>echo “邮件正文” | mail -s “邮件主题(subject)” 邮箱地址</p></blockquote></li><li>正文在文件中<blockquote><p>mail -s “邮件主题(subject)” 邮箱地址 &lt; 邮件正文所在文件<br>cat file | mail -s “邮件主题(subject)” 邮箱地址</p></blockquote></li><li>发送附件<blockquote><p>mail -s “邮件主题(subject)” 邮箱地址 -a 附件</p></blockquote></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>阿里云服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客添加评论功能</title>
    <link href="/2019/07/17/%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD/"/>
    <url>/2019/07/17/%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="yilia主题：gitment评论功能"><a href="#yilia主题：gitment评论功能" class="headerlink" title="yilia主题：gitment评论功能"></a>yilia主题：gitment评论功能</h1><p>下面主要讲述如何使用gitment给yilia主题添加评论功能</p><h2 id="1-Register-a-new-OAuth-application"><a href="#1-Register-a-new-OAuth-application" class="headerlink" title="1. Register a new OAuth application"></a>1. Register a new OAuth application</h2><p><a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">注册OAuth</a><br><a id="more"></a></p><p><img src="https://gitee.com/huster_ning/image/raw/master/image/%E6%B3%A8%E5%86%8C.png" srcset="/img/loading.gif" alt="注册"></p><p>注册完成后能够得到<code>Client ID</code>和<code>Client Serect</code></p><h2 id="2-修改配置文件"><a href="#2-修改配置文件" class="headerlink" title="2. 修改配置文件"></a>2. 修改配置文件</h2><p>修改<code>themes/hexo-theme-yilia/_config.yml</code>下的配置文件（注意不是修改根目录下的_config.yml文件）<br>如下图所示<br><img src="https://gitee.com/huster_ning/image/raw/master/image/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png" srcset="/img/loading.gif" alt="配置文件"><br>最后如果不出问题的话<code>hexo g</code> 、<code>hexo d</code>应该就行了</p><h2 id="3-解决一些遇到的bug"><a href="#3-解决一些遇到的bug" class="headerlink" title="3. 解决一些遇到的bug"></a>3. 解决一些遇到的bug</h2><h3 id="bug：github-api-error-redirect-uri-mismatch"><a href="#bug：github-api-error-redirect-uri-mismatch" class="headerlink" title="bug：github-api-error-redirect-uri-mismatch"></a>bug：github-api-error-redirect-uri-mismatch</h3><p><a href="https://stackoverflow.com/questions/34730153/github-api-error-redirect-uri-mismatch" target="_blank" rel="noopener">参考Stack Overflow</a></p><h3 id="bug：object-ProgressEvent"><a href="#bug：object-ProgressEvent" class="headerlink" title="bug：object ProgressEvent"></a>bug：object ProgressEvent</h3><p>由于服务器认证域名过期，修改服务器即可，<br>修改<code>themes/hexo-theme-yilia/layout/_partial/post/gitment.ejs</code>文件<br>将如下代码<br><pre><code class="hljs undefined"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"//imsun.github.io/gitment/style/default.css"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"//imsun.github.io/gitment/dist/gitment.browser.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></p><p>修改成如下：<br><pre><code class="hljs undefined"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/default.css"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/gitment.browser.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></p><p><a href="https://sjq597.github.io/2018/05/18/Hexo-%E4%BD%BF%E7%94%A8Gitment%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD/" target="_blank" rel="noopener">参考</a></p><h1 id="fluid主题：valine评论"><a href="#fluid主题：valine评论" class="headerlink" title="fluid主题：valine评论"></a>fluid主题：valine评论</h1><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p>修改fluid主题目录下的<code>_config.yml</code>文件，如下所示开启评论并选择使用的评论模块为<code>valine</code></p><pre><code class="hljs yml"><span class="hljs-attr">comments:</span>  <span class="hljs-comment"># 评论</span><span class="hljs-attr">    enable:</span> <span class="hljs-literal">true</span>  <span class="hljs-comment"># 开启评论</span><span class="hljs-attr">    type:</span> <span class="hljs-string">valine</span></code></pre><p>然后修改<code>valine</code>模块中中的配置信息, 主要是修改appid、appkey、serverURLS这三处信息, 需要 <a href="https://leancloud.cn/dashboard/login.html#/signup" target="_blank" rel="noopener">注册LeanCloud</a>才能获取appid、appkey, 具体操作可参考<a href="https://valine.js.org/quickstart.html" target="_blank" rel="noopener">文档</a><br><pre><code class="hljs yml"><span class="hljs-comment"># Valine</span><span class="hljs-comment"># 完整文档 https://valine.js.org/configuration.html</span><span class="hljs-comment"># 注意：下列配置项中的 true/false 不要用引号括起来</span><span class="hljs-attr">valine:</span><span class="hljs-attr">  appid:</span> <span class="hljs-string">xxx</span>  <span class="hljs-comment"># 从 LeanCloud 的应用中得到的 appId</span><span class="hljs-attr">  appkey:</span> <span class="hljs-string">xxx</span>  <span class="hljs-comment"># 从 LeanCloud 的应用中得到的 APP Key</span><span class="hljs-attr">  placeholder:</span> <span class="hljs-string">说点什么</span> <span class="hljs-comment"># 评论框占位提示符</span><span class="hljs-attr">  path:</span> <span class="hljs-string">window.location.pathname</span> <span class="hljs-comment"># 当前文章页路径，用于区分不同的文章页，以保证正确读取该文章页下的评论列表</span><span class="hljs-attr">  avatar:</span> <span class="hljs-string">retro</span> <span class="hljs-comment"># Gravatar 头像展示方式</span><span class="hljs-attr">  meta:</span> <span class="hljs-string">['nick',</span> <span class="hljs-string">'mail'</span><span class="hljs-string">,</span> <span class="hljs-string">'link'</span><span class="hljs-string">]</span>  <span class="hljs-comment"># 评论者相关属性</span><span class="hljs-attr">  pageSize:</span> <span class="hljs-number">10</span> <span class="hljs-comment"># 评论列表分页，每页条数</span><span class="hljs-attr">  lang:</span> <span class="hljs-string">zh-CN</span> <span class="hljs-comment"># zh-CN | zh-TW | en | ja</span><span class="hljs-attr">  highlight:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 代码高亮</span><span class="hljs-attr">  recordIP:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 是否记录评论者IP</span><span class="hljs-attr">  serverURLs:</span>  <span class="hljs-string">xxx</span> <span class="hljs-comment"># REST API 服务器地址，国际版不填</span></code></pre></p><h2 id="评论邮件提醒功能"><a href="#评论邮件提醒功能" class="headerlink" title="评论邮件提醒功能"></a>评论邮件提醒功能</h2><p>邮件提醒我使用的是<a href="https://github.com/zhaojun1998/Valine-Admin" target="_blank" rel="noopener">Valine-Admin</a>，参考文档进行Git部署即可。但我在部署时出现了如下错误：</p><p><img src="https://gitee.com/huster_ning/image/raw/master//image/20200701132034.png" srcset="/img/loading.gif" alt=""></p><p>主要是因为Node版本太低了的缘故，需要修改项目中<code>package.json</code>文件中的Node版本，可以将项目fork到自己的仓库中，然后进行修改, 将<code>6.x</code>修改成<code>12.x</code>即可。</p><pre><code class="hljs json">"engines": &#123;    "node": "12.x"  &#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>博客搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java复习笔记</title>
    <link href="/2018/10/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2018/10/28/java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、没有“对象”的java"><a href="#一、没有“对象”的java" class="headerlink" title="一、没有“对象”的java"></a>一、没有“对象”的java</h2><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><ul><li>整数的默认类型是 int </li><li>定义 float 类型时必须在数字后面跟上 F 或者 f </li><li>使用 long 类型时必须在数字后面跟上 L</li></ul><h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><a id="more"></a><p><img src="https://gitee.com/huster_ning/image/raw/master/image/%E4%BC%98%E5%85%88%E7%BA%A7.PNG" srcset="/img/loading.gif" alt="优先级"></p><ul><li><p>静态变量与静态方法属于类所有，因此也叫作<code>类变量</code>、<code>类方法</code>（因此也能理解static方法中不能使用<code>this</code>和<code>super</code>关键字）， <strong>静态变量只能在类主体中定义，不能在方法中定义</strong></p></li><li><p>静态变量与实例变量的区别：静态变量在<code>编译时</code>内存就为其分配空间，直到程序停止才释放；实例变量只有在创建了<code>实例对象</code>时，才会分配空间</p></li></ul><h2 id="二、包"><a href="#二、包" class="headerlink" title="二、包"></a>二、包</h2><p><strong>父包中的类不能直接引用子包中定义的类，import引用父包中所有的类不会引用子包中所有的类</strong></p><h3 id="基础包：java-lang"><a href="#基础包：java-lang" class="headerlink" title="基础包：java.lang"></a>基础包：<code>java.lang</code></h3><ul><li><p>java.lang.Object</p><blockquote><ul><li>所有类的祖先</li><li>仅有一个默认构造方法</li><li>主要成员方法：<blockquote><ul><li>equals(Object obj) : 判断是否为同一对象</li><li>toString() : 返回对象的字符串表示，“类名@对象的十六进制哈希码”</li></ul></blockquote></li></ul></blockquote></li><li><p>包装类</p><blockquote><p>1) 包装类覆盖了Object类的toString()方法，打印时返回对应字符串值<br>2) 数值类都有<code>valueOf(Strings)</code>静态方法，用于创建包装类对象<br>3) 数值类都有<code>parseXXX(Strings)</code>静态方法，用于将字符串转为对应的基本数据类型，<code>parseInteger(String, int radix)</code>按指定进制解析为十进制数</p></blockquote></li></ul><h2 id="三、String理解"><a href="#三、String理解" class="headerlink" title="三、String理解"></a>三、String理解</h2><p><strong><code>10.14补充内容：</code></strong></p><pre><code class="hljs java"><span class="hljs-comment">/*** 下面代码中使用了StringBuilder类和 String.valueOf()方法* */</span>String s = <span class="hljs-string">"xinger"</span>;s = s + <span class="hljs-number">9</span>;<span class="hljs-comment">//s = "xinger9"</span>s = s + <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">9</span>);<span class="hljs-comment">//自动使用了String.valueOf()方法</span></code></pre><blockquote><p>String是final类，不能被继承，字符串本身不可变</p></blockquote><pre><code class="hljs java">&#123;String s =<span class="hljs-string">"xinger"</span>;<span class="hljs-comment">//将常量池中“xinger"的地址赋给引用s</span>s = <span class="hljs-string">"xingxin"</span>;<span class="hljs-comment">//创建了新的对象</span>String s1 = <span class="hljs-string">"xin"</span>;String s2 = s1 + <span class="hljs-string">"ger"</span>;<span class="hljs-comment">//调用了StringBuilder类，创建了新</span><span class="hljs-comment">//的对象，s == s2为false</span>&#125;</code></pre><p>第二个s生成了新的对象</p><p><strong>字符串常量的“+” 与字符串引用的“+”的区别:</strong><br>前者在编译器完成，所得常量放在常量池中，后者在运行期间完成，在堆中创建了新的对象</p><h3 id="2-字符串比较"><a href="#2-字符串比较" class="headerlink" title="2.字符串比较"></a>2.字符串比较</h3><ul><li>== 比较引用而不是值</li><li>equals(Object o) 比较值</li><li>int compareTo() 从左至右比较值的大小,相等返回0</li></ul><h3 id="3-字符串常量池、堆、栈"><a href="#3-字符串常量池、堆、栈" class="headerlink" title="3.字符串常量池、堆、栈"></a>3.字符串常量池、堆、栈</h3><ul><li>String s = “xinger” : constant pool</li><li>String s = new String(“xinger”) : heap</li><li>对象引用 变量 : stack</li></ul><h3 id="4-常用方法"><a href="#4-常用方法" class="headerlink" title="4.常用方法"></a>4.常用方法</h3><ul><li><code>String[] split(String regex,int limit)</code></li></ul><blockquote><p>用来分割字符串，limit用来限制匹配次数，并且获得的数组长度不能大于limit</p></blockquote><h4 id="5-StringBuilder"><a href="#5-StringBuilder" class="headerlink" title="5.StringBuilder"></a>5.StringBuilder</h4><blockquote><p><code>StringBuilder</code>是可变字符串，能够多次修改并且不产生新的对象，一个String不能直接给其赋初值，比如：<code>StringBuilder s = &quot;xinger&quot;</code>这是错误的</p></blockquote><h2 id="四、面向对象"><a href="#四、面向对象" class="headerlink" title="四、面向对象"></a>四、面向对象</h2><h3 id="修饰符访问权限"><a href="#修饰符访问权限" class="headerlink" title="修饰符访问权限"></a>修饰符访问权限</h3><blockquote><p>修饰符的访问权限是java更是面向对象最最基础的知识点</p></blockquote><ul><li>注意：无修饰符就是默认权限，也叫包访问权限，只能被同一包内类访问，与<code>protected</code>有细微区别</li><li>外部类的定义<code>only public, abstract &amp; final</code></li></ul><p><img src="https://gitee.com/huster_ning/image/raw/master/image/%E4%BF%AE%E9%A5%B0%E7%AC%A6.jpg" srcset="/img/loading.gif" alt="修饰符"></p><ul><li>类是对象的抽象，对象是类的实例</li><li>继承：代码重用、可扩展性</li></ul><h3 id="一、封装：隐藏细节、模块化"><a href="#一、封装：隐藏细节、模块化" class="headerlink" title="一、封装：隐藏细节、模块化"></a>一、封装：隐藏细节、模块化</h3><ul><li>定义：<code>封装</code>是指一种将抽象性函数接口的<code>实现细节部分包装</code>、<code>隐藏</code>起来的方法。<br>封装可以防止一个类的代码和数据被外部类定义的代码随机访问。<br>而要访问该类的代码和数据，必须通过严格的<code>接口</code>控制。</li></ul><blockquote><p>从设计上讲，为了<code>实现模块化</code></p><ol><li>以类为最小单元，减少修改带来的连锁效应； <ol><li>可以对成员变量进行更精确的控制（getter, setter）；</li></ol></li></ol><p>从使用上讲，<code>减少了复杂度</code></p><ol><li>代码使用者无需考虑实现细节就能直接使用一个类； <ol><li>更有效的协作；</li></ol></li></ol></blockquote><ul><li>良好的封装能够减少代码的耦合，抵御变化</li></ul><h3 id="二、继承：是一种“is-a-kind-of”的关系"><a href="#二、继承：是一种“is-a-kind-of”的关系" class="headerlink" title="二、继承：是一种“is a kind of”的关系"></a>二、继承：是一种“is a kind of”的关系</h3><h4 id="1-继承的特点"><a href="#1-继承的特点" class="headerlink" title="1.继承的特点"></a>1.继承的特点</h4><blockquote><ul><li>在设计时，它允许创建分等级层次的类，思路更清晰，减少了冗余代码，<code>易于修改</code>；</li><li>定义新类时，可以以原来的类为基础，借助代码的<code>重用</code>，使系统变得<code>容易扩展</code>，提 高了开发效率。</li><li>继承帮助我们统一了函数的调用接口，在增加新类后减少对已有系统的修改。</li></ul></blockquote><h4 id="2-继承的实现"><a href="#2-继承的实现" class="headerlink" title="2.继承的实现"></a>2.继承的实现</h4><blockquote><ul><li>创建子类对象实例时，首先调用子类的构造方法，再由子类的构造方法<code>默认</code>地调用父类的<code>无参数</code>的构造方法(隐式调用)， 生成父类的对象。接下来完成调用子类的构造方法，生成子类的对象。</li><li><code>注意</code>：如果父类没有<code>无参数</code>构造函数，则必须用<code>super()</code>显示调用父类构造函数，并且必须放在第一行(<code>super</code>关键字可以调用父类方法)</li><li>向上转型：父类对象是子类对象的上转型对象，不能操作子类新增的方法与属性，但能操作子类重写的方法（这也是与直接使用父类的区别）</li></ul></blockquote><h3 id="三、抽象类"><a href="#三、抽象类" class="headerlink" title="三、抽象类"></a>三、抽象类</h3><ul><li>抽象类中可能不含有抽象方法，但含有抽象方法的类一定是抽象类</li><li>抽象类不能被实例化，但可以有构造函数</li><li>子类必须实现父类所有的抽象方法，除非子类也是抽象类</li><li>通过子类调用父类非抽象方法</li></ul><h3 id="四、接口"><a href="#四、接口" class="headerlink" title="四、接口"></a>四、接口</h3><ul><li>接口是一种不同于类的引用类型，是一系列抽象方法的集合；</li><li>方法默认为<code>public abstract</code>,变量默认为<code>public static final</code>，接口中的成员变量可以直接通过<code>接口名调用</code></li></ul><h4 id="接口的功能"><a href="#接口的功能" class="headerlink" title="接口的功能"></a>接口的功能</h4><blockquote><ul><li>1.接口提供了一组功能的命名集合，一个类通过实现接口的方式，从而获得接口所声明的抽象方法。</li><li>2.接口定义了不同类交互的标准(一个类可以调用另一个类(实现了某个接口)的接口方法)</li></ul></blockquote><h4 id="接口与抽象类的区别"><a href="#接口与抽象类的区别" class="headerlink" title="接口与抽象类的区别"></a>接口与抽象类的区别</h4><ul><li>抽象层次不同<blockquote><p>抽象类是对类抽象，而接口是对行为的抽象</p></blockquote></li><li>设计层次不同<blockquote><p>抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。</p></blockquote></li></ul><h3 id="五、多态"><a href="#五、多态" class="headerlink" title="五、多态"></a>五、多态</h3><ul><li>定义：<blockquote><p>在代码中为同一名称的方法（接口）提供不同的实现，<br>为一组类提供了统一的交互接口，又保留了类间的差异。</p></blockquote></li><li>类型</li></ul><blockquote><ul><li>编译时多态：方法的重载</li><li>运行时多态 :<blockquote><p>程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程 时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实 例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运 行期间才能决定。</p></blockquote></li></ul></blockquote><ul><li>如何使用多态<blockquote><ul><li>为一组类抽象出公共父类或者接口</li><li>统一方法名</li></ul></blockquote></li><li>好处：统一接口，更易于扩展</li><li>重写原则：<blockquote><ul><li>参数列表完全一致</li><li>子类返回类型小于等于父类方法返回类型，</li><li>子类抛出异常小于等于父类方法抛出异常，</li><li>子类访问权限大于等于父类方法访问权限。</li></ul></blockquote></li></ul><h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><p><img src="https://gitee.com/huster_ning/image/raw/master/image/io.PNG" srcset="/img/loading.gif" alt="io"></p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><ul><li>减少了cast带来的运行时异常，<br>使算法和框架更为通用，减少了冗余代码</li><li>泛型方法<blockquote><ul><li>所有泛型方法声明都有一个类型<code>参数声明</code>部分（由尖括号分隔），该类型参数声明部分在方 法返回类型之前。</li><li>泛型方法体的声明和其他方法一样。注意类型参数<code>只能代表引用型类型</code>(只能是类)，不能是<code>基本类型</code>(比如int 、double)。</li></ul></blockquote></li><li>通配符<blockquote><ul><li>&lt;? extends T&gt; 上界为T</li><li>&lt;? super T&gt;   下界为T</li><li><e extends="" comparable<e="">&gt; : <strong>类型 E 必须实现 Comparable 接口</strong>，并且这个接口的类型是 E</e></li></ul></blockquote></li><li>使用泛型进行排序<pre><code class="hljs java">   <span class="hljs-comment">//使用Comparable接口确保E能够进行比较</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E extends Comparable&lt;E&gt;&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(E[] a)</span> </span>&#123; <span class="hljs-keyword">int</span> n = a.length;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;n-<span class="hljs-number">1</span>; i++)&#123; <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j&lt;n-<span class="hljs-number">1</span>; j++)&#123; <span class="hljs-comment">//使用compareTo()方法进行比较</span><span class="hljs-keyword">if</span>(a[j].compareTo(a[j+<span class="hljs-number">1</span>]) &gt; <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//为什么可以使用接口的compareTo()方法，因为大部分类都已经实现了Comparable接口，否则自己直接在E中实现Comparable接口即可</span>E temp = a[j]; a[j] = a[j+<span class="hljs-number">1</span>];a[j+<span class="hljs-number">1</span>] = temp;&#125; &#125; &#125; &#125;</code></pre></li></ul><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>Throwable 类中定义的方法：</p><ul><li>getMessage()：获得详细的异常信息 </li><li>toString()：获得异常的简短描述 </li><li>printStackTrace()：打印异常发生处栈跟踪信息，包括类名、方法名和所在行数<blockquote><p>用 throws 关键字指出可能出现的异常类型，自己不进行处理，由该函数的调用者处理</p></blockquote></li></ul><p><img src="https://gitee.com/huster_ning/image/raw/master/image/exception.PNG" srcset="/img/loading.gif" alt="exception"></p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><p><img src="https://gitee.com/huster_ning/image/raw/master/image/thread.PNG" srcset="/img/loading.gif" alt="thread"> </p><h3 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h3><p><img src="https://gitee.com/huster_ning/image/raw/master/image/%E5%90%AF%E5%8A%A8%E7%BA%BF%E7%A8%8B.png" srcset="/img/loading.gif" alt="启动线程"></p><h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2><h3 id="类的关系"><a href="#类的关系" class="headerlink" title="类的关系"></a>类的关系</h3><blockquote><p><code>1+3+1</code>: 继承(泛化)、关联、聚合、组合、依赖</p><blockquote><ul><li>聚合：关联的特例，是一种整体与部分的关系（has a）,但不是<code>must has a</code>的关系</li><li>组合：组合也是关联关系的一种特例，他体现的是一种<code>contains-a</code>的关系，这种关系比聚 合更强，也称为强聚合。</li></ul></blockquote></blockquote><h3 id="常见图模型"><a href="#常见图模型" class="headerlink" title="常见图模型"></a>常见图模型</h3><h4 id="静态模型："><a href="#静态模型：" class="headerlink" title="静态模型："></a>静态模型：</h4><ul><li>用例图（Use Case Diagram）：从用户角度描述系统功能。<blockquote><p>用例图的描述：</p><blockquote><ul><li>简要说明</li><li>主事件流和其他事件流 </li><li>前提条件 </li><li>事后条件</li></ul></blockquote></blockquote></li><li>类图（ClassDiagram）：描述对象模型中类与类之间的关系。 </li><li>组件图（ComponentDiagram）：描述系统中各个组件之间的依赖关系，还可以描 述组件的源代码组织结构。 </li><li>部署图（DeploymentDiagram）：定义系统中软硬件的物理体系结构。</li></ul><h4 id="动态态模型："><a href="#动态态模型：" class="headerlink" title="动态态模型："></a>动态态模型：</h4><ul><li>时序图（Sequence Diagram）：显示对象之间的动态协作关系，强调对象之间消息 发送的时间顺序。 <blockquote><p>时序图的构成：</p><ul><li>对象生命线（垂直的虚线）； </li><li>对象激活框（细长矩形）；</li><li>消息（带箭头的水平线 + 消息名）； </li><li>调用：实线段，实心箭头 </li><li>返回：虚线段，枝状箭头  </li><li>顶部方框表示类的对象或类，有3种写法            <blockquote><ol><li>对象名和类名间用冒号隔开，如 c：Car;</li><li>省略对象名称，：Car ;</li><li>只保留对象名，c。</li></ol></blockquote></li></ul></blockquote></li></ul><p><br><br><img src="/2018/10/28/java复习笔记/D:%5Chexo%5Csource%5C_posts%5Cjava%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%5Csequence.PNG" srcset="/img/loading.gif" alt="sequence"><br><br></p><ul><li>活动图（Activity Diagram）：显示活动的顺序控制流。</li><li>状态转换图（StateTransitionDiagram）：描述对象所有可能的状态，以及导致状 态转换的条件。</li></ul><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="1-SOLID原则"><a href="#1-SOLID原则" class="headerlink" title="1.SOLID原则"></a>1.SOLID原则</h3><blockquote><ul><li>单一职责原则 Single Responsibility Principle</li><li>开放闭合原则 Open Closed Principle</li><li>Liskov替换原则 Liskov Substitution Principle</li><li>接口隔离原则 Interface Segregation Principle</li><li>依赖倒置原则 Dependency Inversion Principle </li></ul></blockquote><h3 id="2-OOD模式实例"><a href="#2-OOD模式实例" class="headerlink" title="2.OOD模式实例"></a>2.OOD模式实例</h3><h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><ul><li>实例: JButton与ActionListener、气象站</li><li>定义：观察者模式定义了对象之间的一对多依赖，当一个对象改变状态时， 它的所有依赖者都会收到通知并自动更新。</li></ul><h4 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h4><ul><li>实例：咖啡店、java io</li><li>定义：装饰者模式动态地将责任附加到对象上。 若要扩展功能，装饰者提供了比继承更 有弹性的替代方案。</li><li>特点：<blockquote><ul><li>装饰者和被装饰对象拥有相同的超类型。</li><li>可以用一个或者多个装饰者包装一个对象。</li><li>装饰者可以在被装饰对象的行为前/后加上 自己的行为，以达到特定的目的。</li><li>装饰过程可以在运行时动态地完成。</li></ul></blockquote></li></ul><h3 id="3-OOD架构"><a href="#3-OOD架构" class="headerlink" title="3.OOD架构"></a>3.OOD架构</h3><h4 id="模型-视图-控制器-Model-View-Controller-MVC"><a href="#模型-视图-控制器-Model-View-Controller-MVC" class="headerlink" title="模型-视图-控制器 Model-View-Controller (MVC)"></a>模型-视图-控制器 Model-View-Controller (MVC)</h4><h4 id="三层程序设计模型-Three-tier-design-model"><a href="#三层程序设计模型-Three-tier-design-model" class="headerlink" title="三层程序设计模型 Three-tier design model"></a>三层程序设计模型 Three-tier design model</h4><ul><li>表示层 （用户界面）</li></ul><blockquote><ul><li>GUI class </li><li>显示数据，接收操作</li></ul></blockquote><ul><li>业务逻辑层 （问题域层）</li></ul><blockquote><ul><li>PD class </li><li>从用户界面接收请求，根据业务逻辑处理请求，从DA类获得数据/向DA类发 送数据，将处理结果送回表示层</li></ul></blockquote><ul><li>数据访问层<blockquote><ul><li>DA class </li><li>建立与数据库的连接，完成增删改查，关闭连接。</li></ul></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Map的遍历与排序</title>
    <link href="/2018/10/16/Map%E7%9A%84%E9%81%8D%E5%8E%86%E4%B8%8E%E6%8E%92%E5%BA%8F/"/>
    <url>/2018/10/16/Map%E7%9A%84%E9%81%8D%E5%8E%86%E4%B8%8E%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>引言：集合是java比较重要的一个知识点，而集合的遍历尤为重要。<br>  相对来说，Map又是集合中比较难懂的一部分，故今天来讲一下Map的<br>  遍历与排序。</p></blockquote><h2 id="Map的遍历"><a href="#Map的遍历" class="headerlink" title="Map的遍历"></a>Map的遍历</h2><ul><li><p>较为简单的遍历方法可以通过<code>keySet()</code>方法获取Map中的所有的<code>key</code>,<br>然后使用<code>get(key)</code>获取<code>key</code>对应的<code>value</code>,代码如下：</p><pre><code class="hljs java"> Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;String, String&gt;(); map.put(<span class="hljs-string">"1"</span>,<span class="hljs-string">"xinger"</span>); <span class="hljs-comment">//······省略部分代码</span><span class="hljs-keyword">for</span>(String s : map.keySet())&#123;System.out.println(<span class="hljs-string">"key:"</span>+s+<span class="hljs-string">","</span>+<span class="hljs-string">"value:"</span>+map.get(s));&#125;</code></pre></li></ul><a id="more"></a><ul><li><p>通过Map.entrySet()遍历map：Map.entrySet()方法返回该地图的集合视图(<code>Set(Map.Entry&lt;K,V&gt;)</code>)</p><pre><code class="hljs java"><span class="hljs-keyword">for</span>(Map.Entry&lt;String, String&gt; entry : map.entrySet())&#123;  <span class="hljs-comment">//参数类型请灵活处理</span>System.out.println(<span class="hljs-string">"key:"</span>+entry.getKey()+<span class="hljs-string">","</span>+<span class="hljs-string">"value:"</span>+entry.getValue());&#125;</code></pre></li><li><p>通过迭代器遍历Map:</p><pre><code class="hljs java">Iterator(Map.Entry&lt;String, String&gt;) ite = map.entrySet().iterator();<span class="hljs-keyword">while</span>(ite.hasNext())&#123;Map.Entry&lt;String, String&gt; entry = ite.next();System.out.println(<span class="hljs-string">"key:"</span>+entry.getKey()+<span class="hljs-string">","</span>+<span class="hljs-string">"value:"</span>+entry.getValue());z&#125;</code></pre></li></ul><h2 id="Map的排序"><a href="#Map的排序" class="headerlink" title="Map的排序"></a>Map的排序</h2><ul><li><p>利用TreeMap类进行排序：<code>TreeMap</code>是默认按<code>key</code>的升序排序，若要改变排序方式，需要使用<strong>比较器</strong>：<code>Comparator</code><br>并使用构造器<code>TreeMap(Comparator&lt;? super K&gt; comparator)</code>,注意到泛型<code>? super K</code>,故本质还是进行按<code>key</code>排序。</p><pre><code class="hljs java">Map&lt;String,String&gt; map = <span class="hljs-keyword">new</span> TreeMap&lt;String, String&gt;(<span class="hljs-keyword">new</span> Comparator&lt;String&gt;()&#123;                <span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(String o1, String o2)</span> </span>&#123;<span class="hljs-keyword">return</span>  o2.compareTo(p1);&#125;);</code></pre></li><li><p>Map按value排序：实现Comparator接口，并重写<code>compare(Object o1, Object o2)</code>方法</p><pre><code class="hljs java">List&lt;Map.Entry&lt;String, Integer&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Map.Entry&lt;String, Integer&gt;&gt;(map.entrySet());   <span class="hljs-comment">//排序</span>   Collections.sort(list, <span class="hljs-keyword">new</span> Comparator&lt;Map.Entry&lt;String, Integer&gt;&gt;()&#123;<span class="hljs-comment">//内部类</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Entry&lt;String, Integer&gt; o1, Entry&lt;String, Integer&gt; o2)</span> </span>&#123;<span class="hljs-keyword">return</span> o2.getValue() - o1.getValue();&#125;      &#125;);</code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Collection</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jdbc</title>
    <link href="/2018/10/05/jdbc/"/>
    <url>/2018/10/05/jdbc/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-JDBC连接MySql"><a href="#1-JDBC连接MySql" class="headerlink" title="1.JDBC连接MySql"></a>1.JDBC连接MySql</h1><p>首先新建一个数据库，<code>create database new_database</code>,<code>use new_database</code>,<code>create new_table(.....)</code>,注意mysql命令<br>要有冒号作为一个语句的结束，然后需要下载驱动包，<a href="http://downloads.mysql.com/archives/c-j/" target="_blank" rel="noopener">http://downloads.mysql.com/archives/c-j/</a>, 解压导入到项目中即可</p><p><font color="#DC1818">注意：下面的代码中的<code>Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;)</code>    注册驱动文件 ，与网上的教程<code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code>有所区别，是由于驱动包版本不同所致，请注意区分</font><br><a id="more"></a><br><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.sql.*;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySql</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String url = <span class="hljs-string">"jdbc:mysql://localhost:3306/database_name?useSSL=false"</span>;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String user = <span class="hljs-string">"root"</span>;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String password = <span class="hljs-string">"xxxxxxx"</span>;<span class="hljs-comment">//the password of your mysql;</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;Connection con = <span class="hljs-keyword">null</span>; Statement statement = <span class="hljs-keyword">null</span>; <span class="hljs-keyword">try</span> &#123; <span class="hljs-comment">//注册驱动文件</span> Class.forName(<span class="hljs-string">"com.mysql.cj.jdbc.Driver"</span>);  <span class="hljs-comment">//连接数据库</span> con = DriverManager.getConnection(url, user, password);<span class="hljs-comment">//查询</span> statement = con.createStatement(); String sql = <span class="hljs-string">"update websites set name='xinger' where id=6;"</span>; <span class="hljs-comment">//update</span> System.out.println(statement.executeUpdate(sql));  <span class="hljs-comment">//System.out.println(ret.toString());</span> sql = <span class="hljs-string">"select * from websites"</span>; ResultSet rs = statement.executeQuery(sql); <span class="hljs-keyword">while</span>(rs.next())&#123;         <span class="hljs-comment">//Retrieve by column name</span>         <span class="hljs-keyword">int</span> id  = rs.getInt(<span class="hljs-string">"id"</span>);         String name = rs.getString(<span class="hljs-string">"name"</span>);         String url = rs.getString(<span class="hljs-string">"url"</span>);         String country = rs.getString(<span class="hljs-string">"country"</span>);         <span class="hljs-comment">//Display values</span>         System.out.print(<span class="hljs-string">"id: "</span> + id);         System.out.print(<span class="hljs-string">",name:"</span> + name);         System.out.print(<span class="hljs-string">", url: "</span> + url);         System.out.println(<span class="hljs-string">", country: "</span> + country);      &#125; rs.close(); statement.close(); con.close();  &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123; System.out.println(e); &#125;  <span class="hljs-keyword">catch</span> (SQLException e) &#123; e.printStackTrace();&#125; &#125;&#125;</code></pre></p><h1 id="2-Statement接口"><a href="#2-Statement接口" class="headerlink" title="2.Statement接口"></a>2.Statement接口</h1><p>   需要使用<code>Connection</code>对象的<code>createStatement()</code>方法创建一个<code>Statement</code>对象；<br>   <code>Statement</code>中的方法：</p><p> <font color="#1EE4F1">boolean execute (String SQL)</font> 如果可以检索到ResultSet对象，则返回一个布尔值true; 否则返回false。使用此方法执行SQLDDL语句或需要使用真正的动态SQL，可使用于执行创建数据库，创建表的SQL语句等等。</p><p><font color="#1EE4F1">int executeUpdate (String SQL)</font>:返回受SQL语句执行影响的行数。使用此方法执行预期会影响多行的SQL语句，例如:INSERT，<br>UPDATE或DELETE语句。</p><p><font color="#1EE4F1">ResultSet executeQuery(String SQL)</font>：返回一个ResultSet对象。 当您希望获得结果集时，请使用此方法，就像使用SELECT语<br>句一样。</p>]]></content>
    
    
    
    <tags>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>First blog</title>
    <link href="/2018/10/05/First-blog/"/>
    <url>/2018/10/05/First-blog/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Hexo-GitHub搭建个人博客"><a href="#Hexo-GitHub搭建个人博客" class="headerlink" title="Hexo+GitHub搭建个人博客"></a>Hexo+GitHub搭建个人博客</h1><h2 id="1-Hexo搭建GitHub-Pages"><a href="#1-Hexo搭建GitHub-Pages" class="headerlink" title="1.Hexo搭建GitHub Pages"></a>1.Hexo搭建GitHub Pages</h2><p>由于大部分过程官方文档中都有详细说明，本文不在讲述。我主要讲述一下如何搭建GitHub Pages:<br>首先在Hexo目录下找到配置文件_config.yml,然后修改deploy中的内容:<br><pre><code class="hljs undefined"><span class="hljs-attribute">deploy</span>:  <span class="hljs-attribute">type</span>: git  <span class="hljs-attribute">repo</span>: <span class="hljs-attribute">https</span>:<span class="hljs-comment">//github.com/your_github_name/your_github_name.github.io.git</span>  <span class="hljs-attribute">branch</span>: master</code></pre></p><p>其中repo是你的github仓库网址<br>最后使用命令hexo s 生成静态文件，hexo d 发布博客</p><a id="more"></a><h2 id="2-更换博客主题"><a href="#2-更换博客主题" class="headerlink" title="2.更换博客主题"></a>2.更换博客主题</h2><p>   <a href="https://hexo.io/themes/" target="_blank" rel="noopener">themes</a>这个是官网提供的主题，而本人使用的主题是华科大佬写的<br><a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">hexo-theme-yilia</a>,比较美观，使用也比较方便。<br>    首先<code>git clone</code>到<code>themes</code>文件夹中，然后在主目录的<code>_config.yml</code><br>中找到theme,改成你说下载的theme名字即可，如图：<br><pre><code class="hljs undefined"><span class="hljs-built_in">theme</span>: hexo-<span class="hljs-built_in">theme</span>-yilia</code></pre></p><p>最后<code>git pull</code>就好了</p><h2 id="3-在博客中加载图片"><a href="#3-在博客中加载图片" class="headerlink" title="3.在博客中加载图片"></a>3.在博客中加载图片</h2><p> 在<code>_config.yml</code>中找到<code>Writing</code>部分，将<code>post_asset_folder</code>改为<code>true</code>,<br> 这样每次<code>hexo new &quot;blog name&quot;</code>时都会自动新建一个同名的资源文件夹，将需<br> 要加载的图片放到该文件夹中,在博客中引用该图片就行了</p> <pre><code class="hljs undefined">&#123;% img [class names] image.jpg [width] [height] [title text [alt text]] %&#125;</code></pre><p>也可以这样引用<code>![](image.jpg)</code>(直接输入图片文件名即可)，但这个无法在首页中显示</p><h2 id="4-更换博客域名"><a href="#4-更换博客域名" class="headerlink" title="4.更换博客域名"></a>4.更换博客域名</h2><p> 作为一个学生党，直接买域名对我来说还是有点小贵，但GitHub给学生提供了一个开发大礼包，学生可以用学校的邮箱进行认证，<br><a href="https://education.github.com/" target="_blank" rel="noopener">申请网址</a>。这个开发大礼包中，对我来说主要有两个比较有用的东西，第一个就是学生可以<br>无限创建私有仓库，另外，可以使用<code>namaCheap</code>申请一个一年的免费域名(<code>.me</code>的顶级域名)，<a href="https://nc.me/" target="_blank" rel="noopener">申请网址</a>，<br>申请到域名后，就可以自定义设置<code>github pages</code>的域名了(代替<code>github.io</code>的域名)，具体操作参考<a href="https://help.github.com/articles/using-a-custom-domain-with-github-pages/" target="_blank" rel="noopener">git pages 官方文档</a> </p><h3 id="4-1-github-pages-with-https"><a href="#4-1-github-pages-with-https" class="headerlink" title="4.1 github pages with https"></a>4.1 github pages with https</h3><p>官方说明：<a href="https://help.github.com/en/github/working-with-github-pages/securing-your-github-pages-site-with-https" target="_blank" rel="noopener">github-pages=with-https</a></p><p>在repository的设置中勾选<code>Enforce HTTPS</code>即可，如果不能勾选，等一段时间即可。</p><p><img src="https://gitee.com/huster_ning/image/raw/master/image/Snipaste_2020-05-22_13-55-31.jpg" srcset="/img/loading.gif" alt="Snipaste_2020-05-22_13-55-31"></p><h3 id="4-2-更换域名的一些坑"><a href="#4-2-更换域名的一些坑" class="headerlink" title="4.2 更换域名的一些坑"></a>4.2 更换域名的一些坑</h3><ul><li><p>域名解析添加CNAME记录：</p><p><img src="https://gitee.com/huster_ning/image/raw/master/image/Snipaste_2020-05-22_13-15-10.jpg" srcset="/img/loading.gif" alt="Snipaste_2020-05-22_13-15-10"></p><p> CNAME:规范名字，允许将多个名字映射到同一台计算机上，即你可以使用多个域名指向同一服务器IP，在这里就是你既可以通过<br>‘github.io’这个域名，又可以通过<code>.me</code>域名访问你的博客。为了保证可以用两个域名访问同一个博客，应该新建一个<code>CNAME</code>文件<br>我新建文件的位置：<br><img src="https://gitee.com/huster_ning/image/raw/master/image/CNAME.PNG" srcset="/img/loading.gif" alt="CNAME"></p></li></ul><p>并写入你的域名，然后提交到github上去，如果直接在github中新建，之后提交博客可能<code>覆盖</code>该文件，导致博客无法访问</p><h2 id="5-插入视频"><a href="#5-插入视频" class="headerlink" title="5.插入视频"></a>5.插入视频</h2><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"560"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"315"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://www.youtube.com/embed/Ilg3gGewQ5U"</span> <span class="hljs-attr">frameborder</span>=<span class="hljs-string">"0"</span> <span class="hljs-attr">allowfullscreen</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span></code></pre><iframe width="60%" height="315" display="block" src="https://www.youtube.com/embed/Ilg3gGewQ5U" frameborder="0" allowfullscreen></iframe><p> <del>初次搭建网站写博客，难免出现疏漏，还望大家海涵</del></p><p>本文主要参考了<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">hexo 文档</a><code>&amp;</code><a href="https://github.com/litten/BlogBackup" target="_blank" rel="noopener">BlogBackup</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>github</tag>
      
      <tag>博客搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
